<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tactical Football ‚Äî ALPHA 15.5.3</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body style="margin: 0; background: #080c14; overflow-x: hidden;">
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useCallback, useMemo, Fragment } = React;

    const FW = 680, FH = Math.max(540, Math.floor(window.innerHeight * 0.74)), PY = FH / 42;
    const ANIM = 550, PANIM = 440, MAX_YAC = 3;
    const GAME_VERSION = "Version ALPHA 15.5.3";
    const rnd = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
    const cl = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
    const R = (x, y) => ({ x, y });
    const dst = (a, b) => { const dx = (a.x - b.x) * 0.533, dy = a.y - b.y; return Math.sqrt(dx * dx + dy * dy); };
    const pick = arr => arr[Math.floor(Math.random() * arr.length)];
    const isPre = d => d === "practice" || d === "preseason";
    // FIX 7 (14.6): Clean yardage formatting ‚Äî no "+-" patterns
    const fmtYds = (yds) => yds >= 0 ? `+${yds}` : `${yds}`;
    const fmtGain = (yds, bo) => {
      if(yds > 0) return `+${yds} to the ${100-(bo+yds) > 50 ? "own " : ""}${Math.min(100-(bo+yds), bo+yds)}`;
      if(yds < 0) return `Loss of ${Math.abs(yds)}`;
      return "No gain";
    };

    const BALL_ARC_MAX = 8;    // Max ball arc height (yards)
    const LERP_QB = 5.0, LERP_REC = 6.0, LERP_DEF = 5.5;
    const LERP_OL = 4.0, LERP_DL = 4.5, LERP_BALL = 6.0;
    const ARRIVE_THRESH = 0.15;
    const lerpVal = (cur, tgt, speed, dt) => {
      const d = tgt - cur;
      return Math.abs(d) < ARRIVE_THRESH ? tgt : cur + d * Math.min(1, speed * dt);
    };

    // ==================== PLAYERS ====================
    const P = (id, pos, lab, spd, str, skl) => ({ id, pos, lab, spd, str, skl });
    const OFF = [
      P("qb","QB","QB",6,5,9), P("rb","RB","RB",8,7,7),
      P("wr1","WR","W1",9,4,8), P("wr2","WR","W2",8,5,7), P("te","TE","TE",6,8,6),
      P("ol1","OL","LT",3,9,5), P("ol2","OL","LG",3,9,5), P("c","OL","C",3,10,5),
      P("ol4","OL","RG",3,9,5), P("ol5","OL","RT",3,9,5),
    ];
    const DEF = [
      P("de1","DL","DE",6,9,6), P("dt1","DL","DT",4,10,5),
      P("dt2","DL","DT",4,10,5), P("de2","DL","DE",6,9,6),
      P("olb1","LB","OLB",7,7,7), P("mlb","LB","MLB",7,8,8), P("olb2","LB","OLB",7,7,7),
      P("cb1","CB","CB",9,4,8), P("cb2","CB","CB",9,4,7),
      P("ss","S","SS",8,6,7), P("fs","S","FS",9,5,8),
    ];
    const gP = (r, id) => r.find(p => p.id === id);
    const OL_IDS = ["ol1","ol2","c","ol4","ol5"];
    const OL_BLK = { de1:"ol1", dt1:"ol2", dt2:"ol4", de2:"ol5" };
    const CB_WR = { cb1:"wr1", cb2:"wr2" };

    // ==================== COVERAGE FINGERPRINTS ====================
    // DB tracking-rate multiplier per scheme per receiver (higher = tighter)
    const COVERAGE = {
      cover2:   { wr1:1.18, wr2:1.18, te:0.62, rb:0.82 },
      base43:   { wr1:0.95, wr2:0.95, te:1.00, rb:1.00 },
      nickel:   { wr1:1.14, wr2:1.14, te:0.76, rb:0.88 },
      blitz:    { wr1:1.00, wr2:1.00, te:1.00, rb:1.00 },
      goalline: { wr1:0.68, wr2:0.68, te:0.78, rb:0.78 },
    };
    // Completion / INT modifiers per scheme per receiver
    const COVERAGE_THROW = {
      cover2:   { wr1:{cp:-8,ip:3}, wr2:{cp:-8,ip:3}, te:{cp:2,ip:2},   rb:{cp:5,ip:-1} },
      base43:   { wr1:{cp:2,ip:0},  wr2:{cp:2,ip:0},  te:{cp:6,ip:-1},  rb:{cp:0,ip:0} },
      nickel:   { wr1:{cp:-5,ip:2}, wr2:{cp:-5,ip:2}, te:{cp:-6,ip:3},  rb:{cp:3,ip:0} },
      blitz:    { wr1:{cp:0,ip:0},  wr2:{cp:0,ip:0},  te:{cp:0,ip:0},   rb:{cp:0,ip:0} },
      goalline: { wr1:{cp:6,ip:-2}, wr2:{cp:6,ip:-2}, te:{cp:-3,ip:1},  rb:{cp:4,ip:-1} },
    };

    // ==================== ROUTES ====================
    const RL = {
      go:(x,y,d)=>[R(x+d,y+5),R(x+d,y+12),R(x+d,y+21),R(x+d,y+30)],
      slant:(x,y,d)=>[R(x+d*4,y+3),R(x+d*10,y+6),R(x+d*16,y+9),R(x+d*20,y+12)],
      post:(x,y,d)=>[R(x,y+5),R(x,y+12),R(x+d*10,y+18),R(x+d*16,y+24)],
      out:(x,y,d)=>[R(x,y+5),R(x,y+10),R(x-d*10,y+10),R(x-d*16,y+10)],
      curl:(x,y)=>[R(x,y+5),R(x,y+11),R(x,y+10),R(x,y+9)],
      flat:(x,y,d)=>[R(x+d*6,y+1),R(x+d*14,y+2),R(x+d*20,y+3),R(x+d*24,y+4)],
      screen:(x,y,d)=>[R(x+d*4,y-2),R(x+d*10,y-3),R(x+d*14,y-2),R(x+d*16,y+2)],
      block:(x,y)=>[R(x,y+0.5),R(x,y+1),R(x,y+1),R(x,y+1)],
      dive:(x,y)=>[R(x,y+2),R(x,y+5),R(x,y+8),R(x,y+11)],
      sweep:(x,y,d)=>[R(x+d*8,y-2),R(x+d*18,y+1),R(x+d*24,y+5),R(x+d*26,y+10)],
      counter:(x,y,d)=>[R(x+d*4,y),R(x+d*6,y+1),R(x-d*10,y+3),R(x-d*14,y+8)],
      toss:(x,y,d)=>[R(x+d*10,y-1),R(x+d*20,y+2),R(x+d*26,y+6),R(x+d*28,y+12)],
      seam:(x,y,d)=>[R(x+d*2,y+1),R(x+d*2,y+6),R(x+d*2,y+14),R(x+d*2,y+22)],
      wheel:(x,y,d)=>[R(x+d*6,y+1),R(x+d*12,y+5),R(x+d*10,y+12),R(x+d*8,y+20)],
      check:(x,y,d)=>[R(x+d*3,y-1),R(x+d*6,y+1),R(x+d*8,y+3),R(x+d*10,y+5)],
      flee:(x,y)=>[R(x,y+2),R(x,y+4),R(x,y-2),R(x,y-3)],
      statue:(x,y,d)=>[R(x,y-1),R(x+d*8,y-2),R(x+d*20,y+1),R(x+d*28,y+6)],
    };

    const FI={qb:R(50,-3),rb:R(50,-7),wr1:R(8,0),wr2:R(92,0),te:R(66,0),ol1:R(38,0),ol2:R(43,0),c:R(50,0),ol4:R(57,0),ol5:R(62,0)};
    const FSG={qb:R(50,-5),rb:R(42,-5),wr1:R(6,0),wr2:R(94,0),te:R(68,0),ol1:R(38,0),ol2:R(43,0),c:R(50,0),ol4:R(57,0),ol5:R(62,0)};
    const FSP={qb:R(50,-5),rb:R(43,-5),wr1:R(5,0),wr2:R(95,0),te:R(78,0),ol1:R(38,0),ol2:R(43,0),c:R(50,0),ol4:R(57,0),ol5:R(62,0)};

    // ==================== MATCHUP MATRIX ====================
    const MX = {
      "Inside Run":   { base43:0, nickel:1, blitz:1, cover2:0, goalline:-2 },
      "Outside Run":  { base43:0, nickel:-1, blitz:1, cover2:-1, goalline:1 },
      "Counter":      { base43:1, nickel:0, blitz:2, cover2:0, goalline:-2 },
      "HB Toss":      { base43:0, nickel:-1, blitz:1, cover2:-1, goalline:1 },
      "QB Sneak":     { base43:1, nickel:1, blitz:0, cover2:1, goalline:-1 },
      "Quick Slants":  { base43:0, nickel:-1, blitz:2, cover2:1, goalline:2 },
      "Deep Post":     { base43:1, nickel:0, blitz:-2, cover2:0, goalline:2 },
      "Play Action":   { base43:1, nickel:0, blitz:-1, cover2:1, goalline:1 },
      "Screen Pass":   { base43:0, nickel:0, blitz:2, cover2:0, goalline:-1 },
      "Four Verticals":{ base43:1, nickel:-1, blitz:-2, cover2:-1, goalline:2 },
      "Flea Flicker":  { base43:1, nickel:0, blitz:-1, cover2:-1, goalline:1 },
      "Statue of Liberty":{base43:1, nickel:1, blitz:0, cover2:0, goalline:0 },
      "QB Draw":       { base43:0, nickel:1, blitz:2, cover2:0, goalline:-2 },
      "Power Run":     { base43:0, nickel:2, blitz:-2, cover2:1, goalline:-1 },
      "Stretch Run":   { base43:-1, nickel:1, blitz:2, cover2:0, goalline:-1 },
      "Out Routes":    { base43:0, nickel:-1, blitz:2, cover2:-2, goalline:1 },
      "Curl/Comeback": { base43:1, nickel:0, blitz:-1, cover2:2, goalline:-2 },
      "TE Seam":       { base43:2, nickel:-2, blitz:0, cover2:-1, goalline:1 },
    };
    const mxLabel = v => v >= 2 ? "GREAT" : v >= 1 ? "GOOD" : v >= 0 ? "OK" : v >= -1 ? "RISKY" : "BAD";
    const mxColor = v => v >= 2 ? "#22c55e" : v >= 1 ? "#4ade80" : v >= 0 ? "#8a9ab0" : v >= -1 ? "#fbbf24" : "#ef4444";

    // ==================== RUN BLOCKING ASSIGNMENTS ====================
    const RUN_BLOCKS = {
      "Inside Run": { ol1:{target:"de1",pushDir:-1}, ol2:{target:"dt1",pushDir:-1}, c:{target:"mlb",pushDir:0}, ol4:{target:"dt2",pushDir:1}, ol5:{target:"de2",pushDir:1}, hole:()=>pick(["center_left","center","center_right"]) },
      "Outside Run": { ol1:{target:"de1",pushDir:1}, ol2:{target:"dt1",pushDir:1}, c:{target:"mlb",pushDir:1}, ol4:{target:"dt2",pushDir:1}, ol5:{target:"de2",pushDir:1}, hole:"left_edge" },
      "Counter": { ol1:{target:"de1",pushDir:1}, ol2:{target:"dt1",pushDir:1}, c:{target:"mlb",pushDir:1}, ol4:{target:"dt2",pushDir:-1}, ol5:{target:"de2",pushDir:-1}, hole:"left_cutback" },
      "HB Toss": { ol1:{target:"de1",pushDir:-1}, ol2:{target:"dt1",pushDir:-1}, c:{target:"mlb",pushDir:-1}, ol4:{target:"dt2",pushDir:-1}, ol5:{target:"de2",pushDir:-1}, hole:"right_edge" },
      "QB Sneak": { ol1:{target:"de1",pushDir:-1}, ol2:{target:"dt1",pushDir:-1}, c:{target:"dt1",pushDir:0}, ol4:{target:"dt2",pushDir:1}, ol5:{target:"de2",pushDir:1}, hole:"center" },
      "Power Run": { ol1:{target:"de1",pushDir:-1}, ol2:{target:"dt1",pushDir:1}, c:{target:"mlb",pushDir:1}, ol4:{target:"dt2",pushDir:1}, ol5:{target:"de2",pushDir:1}, hole:"right_b_gap" },
      "Stretch Run": { ol1:{target:"de1",pushDir:1}, ol2:{target:"dt1",pushDir:1}, c:{target:"mlb",pushDir:1}, ol4:{target:"dt2",pushDir:1}, ol5:{target:"de2",pushDir:1}, hole:"right_edge" },
    };

    // ==================== PLAYS ====================
    const PLAYS = {
      run: [
        { name:"Inside Run", icon:"üèà", type:"run", cat:"staple", tooltip:"RB goes straight up the middle through the linemen", brief:"Your basic run up the middle.", desc:["Handoff at snap, RB hits the gap."], weak:"Goal Line", weakWhy:"Goal line packs the box ‚Äî every gap is plugged.", strong:"Nickel", strongWhy:"Nickel pulls a linebacker for a DB ‚Äî softer middle, easier to push through.", formation:FI, routes:{wr1:f=>RL.go(f.wr1.x,0,0),wr2:f=>RL.go(f.wr2.x,0,0),te:f=>RL.block(f.te.x,0),rb:f=>RL.dive(f.rb.x,f.rb.y)} },
        { name:"Outside Run", icon:"‚ÜóÔ∏è", type:"run", cat:"staple", tooltip:"RB takes it wide around the edge", brief:"RB takes it wide left.", desc:["Handoff at snap, RB heads for the outside edge."], weak:"Nickel", weakWhy:"Extra DB sits on the edge waiting for exactly this.", strong:"Blitz", strongWhy:"Blitzing linebackers vacate the edge ‚Äî nobody left to contain.", formation:FI, routes:{wr1:f=>RL.block(f.wr1.x,0),wr2:f=>RL.go(f.wr2.x,0,0),te:f=>RL.block(f.te.x,0),rb:f=>RL.sweep(f.rb.x,f.rb.y,-1)} },
        { name:"Counter", icon:"üîÑ", type:"run", cat:"staple", tooltip:"Fake one direction, cut back the other way", brief:"Fake one way, cut back the other.", desc:["Punishes aggressive defenses."], weak:"Goal Line", weakWhy:"Goal line is too packed ‚Äî nowhere to cut back to.", strong:"Blitz", strongWhy:"Blitzing linebackers overcommit, leaving huge cutback lanes.", formation:FI, routes:{wr1:f=>RL.go(f.wr1.x,0,0),wr2:f=>RL.block(f.wr2.x,0),te:f=>RL.block(f.te.x,0),rb:f=>RL.counter(f.rb.x,f.rb.y,1)} },
        { name:"HB Toss", icon:"‚ö°", type:"run", cat:"special", tossFumble:0.08, tooltip:"Quick pitch wide ‚Äî big play potential, fumble risk", brief:"Quick pitch wide right.", desc:["Fast edge attack. 8% fumble."], weak:"Cover 2", weakWhy:"Cover 2 safety is already sitting in the flat waiting for the toss.", strong:"Goal Line", strongWhy:"Goal line stacks the middle ‚Äî the edge is wide open for speed.", formation:FI, routes:{wr1:f=>RL.block(f.wr1.x,0),wr2:f=>RL.go(f.wr2.x,0,0),te:f=>RL.flat(f.te.x,0,1),rb:f=>RL.toss(f.rb.x,f.rb.y,1)} },
        { name:"QB Sneak", icon:"üí™", type:"run", cat:"special", qbSneak:true, tooltip:"QB pushes forward behind the center", brief:"QB pushes forward 1-2 yards.", desc:["Short yardage power."], weak:"Goal Line", weakWhy:"They're expecting it ‚Äî the entire line is stacked to stop exactly this.", strong:"Nickel", strongWhy:"Nickel has a lighter front ‚Äî easier to push through for a yard.", formation:FI, routes:{wr1:f=>RL.go(f.wr1.x,0,0),wr2:f=>RL.go(f.wr2.x,0,0),te:f=>RL.block(f.te.x,0),rb:f=>RL.block(f.rb.x,f.rb.y)} },
        { name:"Power Run", icon:"üí™", type:"run", cat:"staple", tooltip:"RB follows a lead blocker into a specific gap", brief:"RB follows a lead blocker into the gap.", desc:["Lead blocker clears the path, RB follows through.","Almost guaranteed 2-3 yards. Lower upside but very hard to stop for zero.","Your short yardage workhorse ‚Äî 3rd and 2, goal line situations.","Slower to develop than Inside Run, but more physical."], weak:"Blitz", weakWhy:"Blitzers hit the gap before the lead blocker can set up.", strong:"Nickel", strongWhy:"Lighter front can't handle the physicality ‚Äî power wins.", formation:FI, routes:{wr1:f=>RL.go(f.wr1.x,0,0),wr2:f=>RL.go(f.wr2.x,0,0),te:f=>RL.block(f.te.x,0),rb:f=>RL.dive(f.rb.x,f.rb.y)} },
        { name:"Stretch Run", icon:"‚ÜîÔ∏è", type:"run", cat:"staple", tooltip:"RB moves sideways reading blocks, looking for a lane", brief:"RB takes the handoff moving sideways, reads blocks.", desc:["Patient run ‚Äî RB moves laterally looking for the first opening.","High variance. Sometimes stuffed for nothing, sometimes breaks big.","Best when your OL can sustain blocks and create movement.","Rewards patience ‚Äî don't just hit the first hole."], weak:"Base 4-3", weakWhy:"Disciplined DEs keep the edge sealed ‚Äî nowhere to stretch to.", strong:"Blitz", strongWhy:"Overcommitting defenders open up cutback lanes all over the field.", formation:FI, routes:{wr1:f=>RL.go(f.wr1.x,0,0),wr2:f=>RL.block(f.wr2.x,0),te:f=>RL.block(f.te.x,0),rb:f=>RL.sweep(f.rb.x,f.rb.y,1)} },
      ],
      pass: [
        { name:"Quick Slants", icon:"‚ö°", type:"pass", cat:"staple", primary:"wr1", tooltip:"Receivers cut inside for a quick throw", brief:"Short fast routes inside.", desc:["Ball out fast."], weak:"Nickel", weakWhy:"Extra DB clogs the middle where slants want to go.", strong:"Blitz", strongWhy:"Quick release beats the rush ‚Äî ball's out before the blitz gets there.", formation:FSG, routes:{wr1:f=>RL.slant(f.wr1.x,0,1),wr2:f=>RL.slant(f.wr2.x,0,-1),te:f=>RL.seam(f.te.x,0,-1),rb:f=>RL.check(f.rb.x,f.rb.y,-1)} },
        { name:"Deep Post", icon:"üéØ", type:"pass", cat:"staple", primary:"wr1", tooltip:"Receiver sprints deep then angles to the middle", brief:"WR sprints deep to middle.", desc:["Requires 2-3 actions of pocket time."], weak:"Blitz", weakWhy:"The rush gets there before the deep route develops ‚Äî you'll be sacked.", strong:"Goal Line", strongWhy:"Goal line has zero deep coverage ‚Äî nobody back there to stop the post.", formation:FSG, routes:{wr1:f=>RL.post(f.wr1.x,0,1),wr2:f=>RL.out(f.wr2.x,0,1),te:f=>RL.curl(f.te.x,0),rb:f=>RL.check(f.rb.x,f.rb.y,-1)} },
        { name:"Play Action", icon:"üé≠", type:"pass", cat:"situational", primary:"wr1", playAction:true, tooltip:"Fake the handoff, then throw", brief:"Fake handoff, then throw.", desc:["Needs established run game."], weak:"Blitz", weakWhy:"Blitzers don't care about the fake ‚Äî they're rushing no matter what.", strong:"Base 4-3", strongWhy:"Linebackers bite hard on the run fake, leaving receivers wide open.", formation:FI, routes:{wr1:f=>RL.post(f.wr1.x,0,1),wr2:f=>RL.out(f.wr2.x,0,1),te:f=>RL.seam(f.te.x,0,-1),rb:f=>RL.dive(f.rb.x,f.rb.y)} },
        { name:"Screen Pass", icon:"ü™§", type:"pass", cat:"situational", primary:"rb", tooltip:"Let the rush come, dump to the RB with blockers", brief:"Let rush come, dump to RB.", desc:["Turns pressure against them."], weak:"Base 4-3", weakWhy:"Patient linebackers read the screen and blow it up in the backfield.", strong:"Blitz", strongWhy:"Let the rushers fly past, dump to RB with blockers ahead.", formation:FSG, routes:{wr1:f=>RL.go(f.wr1.x,0,0),wr2:f=>RL.go(f.wr2.x,0,0),te:f=>RL.flat(f.te.x,0,-1),rb:f=>RL.screen(f.rb.x,f.rb.y,-1)} },
        { name:"Four Verticals", icon:"üöÄ", type:"pass", cat:"situational", primary:"wr1", tooltip:"Every receiver goes deep", brief:"Every receiver deep.", desc:["4 targets vs 2 safeties."], weak:"Blitz", weakWhy:"You need time for deep routes ‚Äî the blitz gets there first.", strong:"Base 4-3", strongWhy:"Four receivers deep vs two safeties ‚Äî the math works in your favor.", formation:FSP, routes:{wr1:f=>RL.go(f.wr1.x,0,0),wr2:f=>RL.go(f.wr2.x,0,0),te:f=>RL.seam(f.te.x,0,-1),rb:f=>RL.wheel(f.rb.x,f.rb.y,-1)} },
        { name:"Out Routes", icon:"‚Ü™Ô∏è", type:"pass", cat:"staple", primary:"wr1", tooltip:"Receivers cut to the sideline at 8-12 yards", brief:"Receivers cut toward the sideline at 8-12 yards.", desc:["Move the chains ‚Äî reliable 8-12 yard gains.","If the receiver gets out of bounds, the clock stops.","Low interception risk since the throw goes toward the sideline.","Doesn't work well against zones that cover the flats."], weak:"Cover 2", weakWhy:"Cover 2 CBs sit right in the out route area ‚Äî they're waiting for it.", strong:"Blitz", strongWhy:"Vacated zones leave the sideline wide open ‚Äî easy pitch and catch.", formation:FSG, routes:{wr1:f=>RL.out(f.wr1.x,0,1),wr2:f=>RL.out(f.wr2.x,0,-1),te:f=>RL.curl(f.te.x,0),rb:f=>RL.check(f.rb.x,f.rb.y,-1)} },
        { name:"Curl/Comeback", icon:"üîÉ", type:"pass", cat:"staple", primary:"wr1", tooltip:"Run upfield then turn back toward the QB", brief:"Receivers sprint upfield then turn back to the QB.", desc:["Works when defenders give a big cushion.","The receiver sells the deep route, then stops and turns around.","Safe throw ‚Äî the receiver is coming back toward the ball.","Useless against press coverage that jams at the line."], weak:"Goal Line", weakWhy:"Press coverage jams at the line ‚Äî can't even start the route.", strong:"Cover 2", strongWhy:"Soft zones give a big cushion ‚Äî space to turn back and catch.", formation:FSG, routes:{wr1:f=>RL.curl(f.wr1.x,0),wr2:f=>RL.curl(f.wr2.x,0),te:f=>RL.flat(f.te.x,0,-1),rb:f=>RL.check(f.rb.x,f.rb.y,-1)} },
        { name:"TE Seam", icon:"‚¨ÜÔ∏è", type:"pass", cat:"staple", primary:"te", tooltip:"Tight end up the middle between linebackers and safeties", brief:"TE runs straight up the middle between LBs and safeties.", desc:["Exploits the gap between linebacker zones and safety coverage.","The TE is your biggest, toughest receiver ‚Äî he can take a hit.","Dangerous in the middle of the field, 10-20 yard gains.","Needs time in the pocket since the route develops downfield."], weak:"Nickel", weakWhy:"The extra DB covers the middle seam ‚Äî that's exactly what Nickel is for.", strong:"Base 4-3", strongWhy:"Linebackers drop shallow in 4-3, leaving the seam wide open behind them.", formation:FSG, routes:{wr1:f=>RL.go(f.wr1.x,0,0),wr2:f=>RL.slant(f.wr2.x,0,-1),te:f=>RL.seam(f.te.x,0,-1),rb:f=>RL.check(f.rb.x,f.rb.y,-1)} },
      ],
      trick: [
        { name:"Flea Flicker", icon:"ü™∞", type:"trick", flea:true, fleaFumble:0.08, primary:"wr1", tooltip:"Fake handoff, pitch back to QB, throw deep", brief:"Fake handoff, pitch back, throw deep.", desc:["8% fumble risk."], weak:"Cover 2", weakWhy:"Two safeties sit deep ‚Äî the fake doesn't pull them up.", strong:"Base 4-3", strongWhy:"Safeties bite hard on the run fake, leaving the deep field empty.", formation:FI, routes:{wr1:f=>RL.post(f.wr1.x,0,1),wr2:f=>RL.go(f.wr2.x,0,0),te:f=>RL.seam(f.te.x,0,-1),rb:f=>RL.flee(f.rb.x,f.rb.y)} },
        { name:"Statue of Liberty", icon:"üóΩ", type:"trick", statue:true, tooltip:"Fake a throw, secretly hand to the RB", brief:"Fake pass, slip to RB.", desc:["Pure surprise."], weak:"Blitz", weakWhy:"Blitzers crash the backfield ‚Äî the RB has zero blockers.", strong:"Nickel", strongWhy:"Nickel ignores the backfield watching receivers ‚Äî RB sneaks out.", formation:FI, routes:{wr1:f=>RL.go(f.wr1.x,0,1),wr2:f=>RL.go(f.wr2.x,0,0),te:f=>RL.flat(f.te.x,0,-1),rb:f=>RL.statue(f.rb.x,f.rb.y,1)} },
        { name:"QB Draw", icon:"üé≠", type:"trick", qbDraw:true, tooltip:"Drop back like a pass, then QB runs through the gaps", brief:"Fake pass, QB runs through gaps.", desc:["Punishes heavy rush."], weak:"Goal Line", weakWhy:"Goal line packs every gap ‚Äî nowhere for the QB to run.", strong:"Blitz", strongWhy:"Blitzers fly upfield past the QB, leaving the middle wide open.", formation:FSG, routes:{wr1:f=>RL.go(f.wr1.x,0,0),wr2:f=>RL.go(f.wr2.x,0,0),te:f=>RL.block(f.te.x,0),rb:f=>RL.block(f.rb.x,f.rb.y)} },
      ],
    };

    const getRoutes = play => {
      const r = {};
      for (const id of ["wr1","wr2","te","rb"]) { if (play.routes[id]) r[id] = play.routes[id](play.formation); }
      return r;
    };

    // ==================== DEFENSE ====================
    const DEFS = {
      base43:{ name:"4-3 Base", desc:"Standard defense. Balanced against run and pass.", pos:{de1:R(34,1.5),dt1:R(46,1),dt2:R(54,1),de2:R(66,1.5),olb1:R(28,5),mlb:R(50,5),olb2:R(72,5),cb1:R(10,7),cb2:R(90,7),ss:R(55,14),fs:R(45,18)} },
      nickel:{ name:"Nickel", desc:"Extra DB in coverage. Strong vs pass, weaker against run inside.", pos:{de1:R(36,1.5),dt1:R(46,1),dt2:R(54,1),de2:R(64,1.5),olb1:R(30,5),mlb:R(50,5),olb2:R(78,5),cb1:R(8,6),cb2:R(92,6),ss:R(60,12),fs:R(40,18)} },
      blitz:{ name:"Blitz", desc:"LBs rush QB. Extreme pressure, but fewer defenders deep.", pos:{de1:R(34,1.5),dt1:R(46,1),dt2:R(54,1),de2:R(66,1.5),olb1:R(38,2.5),mlb:R(50,3),olb2:R(62,2.5),cb1:R(10,7),cb2:R(90,7),ss:R(55,8),fs:R(45,15)} },
      cover2:{ name:"Cover 2", desc:"Two deep safeties. Shuts down deep balls, leaves short middle open.", pos:{de1:R(34,1.5),dt1:R(46,1),dt2:R(54,1),de2:R(66,1.5),olb1:R(30,5),mlb:R(50,5.5),olb2:R(70,5),cb1:R(10,4),cb2:R(90,4),ss:R(30,18),fs:R(70,18)} },
      goalline:{ name:"Goal Line", desc:"Packed line. Stops short runs, zero deep coverage.", pos:{de1:R(32,1),dt1:R(44,0.8),dt2:R(56,0.8),de2:R(68,1),olb1:R(36,2.5),mlb:R(50,2.5),olb2:R(64,2.5),cb1:R(14,4),cb2:R(86,4),ss:R(50,8),fs:R(50,13)} },
    };

    const pickDef = (dn, dst, bo, diff) => {
      const w = { base43:30, nickel:22, blitz:15, cover2:22, goalline:0 };
      if (bo >= 95 && dst <= 3) w.goalline = 50;
      else if (bo >= 90) w.goalline = 20;
      if (dst <= 2 && bo < 90) { w.base43 += 15; w.blitz += 10; }
      if (dst >= 8) { w.nickel += 15; w.cover2 += 15; }
      if (dn >= 3 && dst >= 5) { w.nickel += 10; w.cover2 += 10; w.blitz += 8; }
      const e = Object.entries(w), t = e.reduce((s,[,v])=>s+v,0);
      let r = Math.random() * t;
      for (const [k,v] of e) { r -= v; if (r <= 0) return { key:k, ...DEFS[k] }; }
      return { key:"base43", ...DEFS.base43 };
    };

    // ==================== OL SYSTEM ====================
    function initMatchups(scheme) {
      const m = {};
      for (const [dl, ol] of Object.entries(OL_BLK)) {
        const d = gP(DEF,dl), o = gP(OFF,ol);
        m[dl] = { olId:ol, integrity: cl(90 + (o.str - d.str) * 3 + rnd(-5,5), 60, 100) };
      }
      if (scheme.key === "blitz") m.mlb = { olId:"c", integrity: 85 + rnd(-5,5) };
      return m;
    }

    function degradeMatchups(mu, scheme, factor) {
      const f = factor || 1;
      const n = {};
      for (const [id, m] of Object.entries(mu)) {
        const dl = gP(DEF,id);
        const deg = ((dl?.str || 7) * 1.2 + rnd(2,8) + (scheme.key === "blitz" ? 4 : 0)) * f;
        n[id] = { ...m, integrity: Math.max(0, m.integrity - deg) };
      }
      return n;
    }

    const getPocket = mu => {
      const v = Object.values(mu).map(m=>m.integrity);
      return v.length ? Math.round(v.reduce((a,b)=>a+b,0)/v.length) : 100;
    };
    const getWeak = mu => {
      let w=999,s=null;
      for (const [id,m] of Object.entries(mu)) { if (m.integrity < w) { w=m.integrity; s=id; } }
      return {id:s,int:w};
    };
    const getPocketLR = mu => {
      const side = ids => { const v=ids.map(id=>mu[id]?.integrity).filter(x=>x!=null); return v.length?Math.round(v.reduce((a,b)=>a+b,0)/v.length):100; };
      return { left:side(["de1","dt1"]), right:side(["dt2","de2"]) };
    };

    // CHANGE 2: OL anchored at line of scrimmage ‚Äî does not follow QB
    function computePassOL(mu) {
      const pos = {}, cx = 50, losY = 0;
      const slots = [{id:"ol1",xOff:-12,cv:0},{id:"ol2",xOff:-6,cv:0.3},{id:"c",xOff:0,cv:0.5},{id:"ol4",xOff:6,cv:0.3},{id:"ol5",xOff:12,cv:0}];
      slots.forEach(s => {
        let pct = 1;
        for (const m of Object.values(mu)) { if (m.olId === s.id) pct = Math.min(pct, m.integrity/100); }
        const pushBack = (1-pct) * 3;
        pos[s.id] = R(cl(cx + s.xOff, 5, 95), losY - pushBack + s.cv * 0.5);
      });
      return pos;
    }

    function computeRunOL(playName, defPos, scheme, mxRating) {
      const blocks = RUN_BLOCKS[playName];
      if (!blocks) return { olPos: {}, defAdj: {}, holeInfo: null };
      const olPos = {}, defAdj = {};
      const bonusPush = mxRating >= 1 ? 3 : mxRating <= -1 ? -2 : 0; 
      
      for (const [olId, assignment] of Object.entries(blocks)) {
        if (olId === "hole") continue;
        const ol = gP(OFF, olId), target = assignment.target;
        const defP = defPos[target];
        if (!defP || !ol) continue;
        
        const olStr = ol.str, dlStr = gP(DEF, target)?.str || 7;
        const pushSuccess = (olStr - dlStr + 2 + bonusPush) * 0.12 + 0.5 + Math.random() * 0.2;
        const pushDist = cl(pushSuccess * 6, 0, 10);
        const dir = assignment.pushDir;
        
        const startPos = defP;
        olPos[olId] = R(startPos.x + dir * -2, startPos.y + 0.5);
        defAdj[target] = R(defP.x + dir * pushDist, defP.y + (dir === 0 ? pushDist * 0.3 : 0));
      }
      
      const holeName = typeof blocks.hole === "function" ? blocks.hole() : blocks.hole;
      let holeInfo = null;
      if (holeName === "center") {
        const leftDT = defAdj.dt1 || defPos.dt1;
        const rightDT = defAdj.dt2 || defPos.dt2;
        if (leftDT && rightDT) holeInfo = { x: (leftDT.x + rightDT.x) / 2, y: 3, width: Math.abs(rightDT.x - leftDT.x), name: "between the guards" };
      } else if (holeName === "center_left") {
        const de = defAdj.de1 || defPos.de1;
        const dt = defAdj.dt1 || defPos.dt1;
        if (de && dt) holeInfo = { x: (de.x + dt.x) / 2, y: 3, width: Math.abs(dt.x - de.x), name: "left A gap" };
      } else if (holeName === "center_right") {
        const de = defAdj.de2 || defPos.de2;
        const dt = defAdj.dt2 || defPos.dt2;
        if (de && dt) holeInfo = { x: (de.x + dt.x) / 2, y: 3, width: Math.abs(dt.x - de.x), name: "right B gap" };
      } else if (holeName === "left_edge") {
        const de = defAdj.de1 || defPos.de1;
        if (de) holeInfo = { x: de.x - 8, y: 2, width: 12, name: "outside left" };
      } else if (holeName === "right_edge") {
        const de = defAdj.de2 || defPos.de2;
        if (de) holeInfo = { x: de.x + 8, y: 2, width: 12, name: "outside right" };
      } else if (holeName === "left_cutback") {
        const dt = defAdj.dt2 || defPos.dt2;
        if (dt) holeInfo = { x: dt.x - 10, y: 3, width: 10, name: "cutback left" };
      } else if (holeName === "right_b_gap") {
        const dt = defAdj.dt2 || defPos.dt2;
        const de = defAdj.de2 || defPos.de2;
        if (dt && de) holeInfo = { x: (dt.x + de.x) / 2, y: 3, width: Math.abs(de.x - dt.x), name: "right B gap" };
      }
      
      return { olPos, defAdj, holeInfo };
    }

    // CHANGES 2,5,6: Anchored DL, coverage fingerprints, receiver seeds
    function computeDefPass(scheme, ph, qbP, offP, olP, mu, lookDir, diff, seeds, blitzUncov) {
      const pos = {}, ms = Math.min(ph, 5);
      for (const p of DEF) {
        const s = scheme.pos[p.id]; if (!s) continue;
        if (p.pos === "DL") {
          // CHANGE 2: DL anchored at LOS ‚Äî penetrates based on integrity, not QB position
          const m = mu[p.id];
          const ol = m ? olP[m.olId] : null;
          const pct = m ? m.integrity / 100 : 1;
          const penetration = (1 - pct) * 7;
          let rx = s.x, ry = s.y - penetration;
          if (ol && pct > 0.15) {
            ry = Math.max(ry, ol.y + 0.5);
            rx += (ol.x - rx) * pct * 0.5;
            if (p.id === "de1") rx = Math.min(rx, ol.x - 2);
            if (p.id === "de2") rx = Math.max(rx, ol.x + 2);
          }
          pos[p.id] = R(rx, ry);
        } else if (p.pos === "LB") {
          if (scheme.key === "blitz") {
            // CHANGE 2: Blitzing LBs anchored at LOS, push via integrity/phase
            const m = mu[p.id];
            let rx = s.x, ry;
            if (m) {
              const ol = olP[m.olId], pct = m.integrity / 100;
              ry = s.y - (1 - pct) * 7;
              if (ol && pct > 0.15) { ry = Math.max(ry, ol.y + 0.5); rx += (ol.x - rx) * pct * 0.3; }
            } else {
              ry = s.y - ms * 1.2;
            }
            pos[p.id] = R(rx, ry);
          } else {
            if (ms >= 2) {
              const threats = ["te","rb"].map(id=>offP[id]).filter(Boolean);
              const near = threats.reduce((a,b)=>(!a||dst(s,b)<dst(s,a)?b:a),null);
              if (near) pos[p.id] = R(s.x+(near.x-s.x)*0.06*ms, s.y+(near.y-s.y)*0.06*ms);
              else pos[p.id] = R(s.x, s.y+ms*0.5);
            } else pos[p.id] = R(s.x, s.y+ms*0.5);
          }
        } else if (p.pos === "CB") {
          const wrId = CB_WR[p.id];
          const wr = offP[wrId];
          if (wr) {
            const sd = p.spd - (gP(OFF,wrId)?.spd||7);
            const dbMod = diff==="practice"?0.83:diff==="preseason"?0.82:diff==="regular"?0.90:1.0;
            // CHANGE 5: Coverage fingerprint adjusts tracking tightness
            const covFactor = COVERAGE[scheme.key]?.[wrId] || 1;
            // CHANGE 6: Per-receiver seed ‚Äî some receivers win/lose their matchup
            const rseed = seeds?.[wrId] || 1;
            // CHANGE 5: Blitz uncovered ‚Äî CB peeled off to rush
            const blitzPen = (scheme.key === "blitz" && blitzUncov === wrId) ? 0.25 : 1;
            // BUG 4 FIX: Phase 1 = tight man coverage, separation builds then tightens (FIX 8)
            const rate = cl((0.75-ms*0.04+sd*0.05)*dbMod*covFactor*blitzPen/rseed,0.12,0.95);
            // FIX 8: Cushion grows until Phase 4, then shrinks as coverage recovers
            const cush = ms <= 4 ? Math.min(3.5, 1.0+(ms-1)*0.6) : Math.max(0.5, 3.5-(ms-4)*0.7);
            pos[p.id] = R(s.x+(wr.x-s.x)*rate, cl(s.y+(wr.y-s.y)*rate-cush,s.y-5,40));
            if (lookDir && ms >= 1) {
              const wrSide = wr.x < 50 ? "left" : "right";
              const cbP = pos[p.id];
              const dxY = (wr.x - cbP.x) * 0.533, dyY = wr.y - cbP.y;
              const dT = Math.sqrt(dxY*dxY + dyY*dyY);
              if (dT > 1) {
                const ux = dxY / dT, uy = dyY / dT;
                if (lookDir === wrSide) { pos[p.id] = R(cbP.x + ux / 0.533, cbP.y + uy); }
                else { pos[p.id] = R(cbP.x - ux * 1.5 / 0.533, cbP.y - uy * 1.5); }
              }
            }
          } else pos[p.id] = s;
        } else if (p.pos === "S") {
          const threats = ["wr1","wr2","te"].map(id=>({id,p:offP[id]})).filter(t=>t.p);
          let targ = threats.reduce((a,b)=>(b.p.y>(a?.p?.y||0)?b:a),null);
          if (lookDir && ms>=1) {
            const lt = threats.filter(t=>lookDir==="left"?t.p.x<40:t.p.x>60);
            if (lt.length) targ = lt[0];
          }
          if (targ?.p) {
            const smod=diff==="practice"?0.83:diff==="preseason"?0.82:diff==="regular"?0.90:1.0;
            // CHANGE 5: Safety coverage modifier per scheme
            let sMod = 1.0;
            if (scheme.key === "cover2") sMod = 0.55;
            else if (scheme.key === "blitz") sMod = 1.3;
            else if (scheme.key === "goalline") sMod = 1.4;
            // CHANGE 5: Blitz uncovered TE ‚Äî safety leaves
            if (scheme.key === "blitz" && blitzUncov === "te" && targ.id === "te") sMod *= 0.2;
            // CHANGE 6: Receiver seed affects safety tracking
            const tSeed = seeds?.[targ.id] || 1;
            const rd=(ms<=1?0.04:0.08)*smod*sMod/tSeed;
            pos[p.id]=R(s.x+(targ.p.x-s.x)*rd*ms,s.y+Math.max(0,(targ.p.y-s.y)*rd*ms));
          }
          else pos[p.id] = s;
        }
      }
      return pos;
    }

    function pursue(prev, rP, step, carrier) {
      const np = {};
      // Slower carriers let defenders close faster (TE=1.25, QB=1.15, WR=1.0, RB=1.0)
      const carrierSlowness = carrier==="te" ? 1.25 : carrier==="qb" ? 1.15 : 1.0;
      for (const p of DEF) {
        const pr = prev[p.id]; if (!pr) continue;
        const intensity = step > 2 ? 1 + (step - 2) * 0.15 : 1;
        const cy = (p.spd*0.45+0.5+step*0.12) * intensity * carrierSlowness, d = dst(pr,rP);
        if (d < 0.5) { np[p.id]={...rP}; continue; }
        np[p.id] = R(pr.x+(rP.x-pr.x)*Math.min(cy/d,1), pr.y+(rP.y-pr.y)*Math.min(cy/d,1));
      }
      return np;
    }

    function nearD(pos, dP) {
      let n=999,nid=null;
      for (const [id,dp] of Object.entries(dP)) { const d=dst(pos,dp); if(d<n){n=d;nid=id;} }
      return {d:n,id:nid,p:gP(DEF,nid)};
    }

    function opn(recId, offP, defP, scheme) {
      const rec = offP[recId]; if (!rec) return {o:0,lab:"N/A",col:"#666"};
      let n=999; for (const dp of Object.values(defP)) { const d=dst(rec,dp); if(d<n)n=d; }
      let o;
      if(n>6) o=3;
      else if(n>4) o=2;
      else if(n>2.5) o=1;
      else if(n>1.5) o=0;
      else o=-1;
      // Adjust openness when defensive scheme gives a significant completion bonus
      if(scheme){
        const ct=COVERAGE_THROW[scheme.key];
        if(ct&&ct[recId]){
          const cpBonus=ct[recId].cp, ipBonus=ct[recId].ip;
          // Net benefit: high cp bonus with low/negative ip = scheme soft spot
          if(cpBonus>=8&&ipBonus<=0) o=Math.min(3,o+2);       // Big soft spot ‚Äî bump up 2 tiers
          else if(cpBonus>=5&&ipBonus<=0) o=Math.min(3,o+1);   // Moderate advantage ‚Äî bump up 1
          else if(cpBonus<=-5&&ipBonus>=2) o=Math.max(-1,o-1);  // Scheme hurts ‚Äî bump down 1
        }
      }
      const labels=[
        {o:-1,lab:"COVERED",col:"#ef4444"},
        {o:0,lab:"TIGHT",col:"#f97316"},
        {o:1,lab:"CONTESTED",col:"#fbbf24"},
        {o:2,lab:"OPEN",col:"#86efac"},
        {o:3,lab:"WIDE OPEN",col:"#22c55e"},
      ];
      // Add SOFT SPOT label for scheme-boosted receivers that were bumped from covered/tight
      if(scheme&&o>=1&&n<=2.5){
        const ct=COVERAGE_THROW[scheme.key];
        if(ct&&ct[recId]&&ct[recId].cp>=5) return {o,lab:"SOFT SPOT",col:"#4ade80"};
      }
      const entry=labels.find(l=>l.o===o)||labels[0];
      return {o:entry.o,lab:entry.lab,col:entry.col};
    }

    function throwProbs(recId,ph,offP,defP,scheme,pi,lookDir,diff) {
      const rec=gP(OFF,recId),op=opn(recId,offP,defP,scheme);
      const presMod=diff==="practice"?0.25:diff==="preseason"?0.5:diff==="regular"?0.75:1.0;
      const pres=((100-pi)*0.6+ph*8+(scheme.key==="blitz"?15:0)+rnd(-5,5))*presMod;
      let cp=0.40+op.o*0.15+rec.skl*0.02-cl(pres,0,100)/250;
      const ipBase=op.o<=0?0.10+ph*0.02:op.o===1?0.04:0.01;
      const cpBonus=diff==="practice"?30:diff==="preseason"?20:diff==="regular"?5:0;
      const ipMult=diff==="practice"?0.05:diff==="preseason"?0.3:diff==="regular"?0.7:1.0;
      const cpCap=diff==="practice"?98:95;
      let cpPct=Math.round(cl(cp*100+cpBonus,10,cpCap)),ipPct=Math.round(cl(ipBase*ipMult,0,1)*100);
      if(lookDir){const rP=offP[recId];if(rP){const opp=(lookDir==="left"&&rP.x>50)||(lookDir==="right"&&rP.x<50);if(opp){cpPct=Math.min(95,cpPct+15);ipPct=Math.max(0,Math.round(ipPct*0.6));}else{ipPct=Math.min(99,ipPct+5);}}}
      // CHANGE 5: Coverage fingerprint throw modifiers
      const cThrow=COVERAGE_THROW[scheme.key];
      if(cThrow&&cThrow[recId]){cpPct=cl(cpPct+cThrow[recId].cp,5,cpCap);ipPct=cl(ipPct+cThrow[recId].ip,0,50);}
      return {cp:cpPct,ip:ipPct,op};
    }

    function doThrow(recId,ph,offP,defP,scheme,pi,lookDir,preProbs,diff) {
      const pr=preProbs||throwProbs(recId,ph,offP,defP,scheme,pi,lookDir,diff),rP=offP[recId];
      // Defender proximity gate ‚Äî scale interception chance by nearest defender distance
      let nearDefDist=99;
      for(const dp of Object.values(defP)){if(dp){const d=dst(rP,dp);if(d<nearDefDist)nearDefDist=d;}}
      const effectiveIp=nearDefDist>=8?0:nearDefDist>=5?Math.round(pr.ip*0.15):nearDefDist>=3?Math.round(pr.ip*0.5):pr.ip;
      if(Math.random()*100<effectiveIp) return {ok:false,int:true,yds:0,msg:`INTERCEPTED targeting ${recId.toUpperCase()}!`,tP:rP,reason:"Defender read the throw and jumped the route."};
      if(Math.random()*100>pr.cp) {
        const defClose=nearDefDist<4;
        const reasons = isPre(diff)?[
          {msg:"throw went too high",why:"Defenders closing in made it hard to throw accurately ‚Äî the ball sailed over the receiver's head."},
          {msg:"throw hit the ground",why:"The QB couldn't plant his feet with defenders closing in ‚Äî the throw bounced short."},
          ...(defClose?[{msg:"defender knocked it away",why:`The defender was right on the receiver (${pr.op.lab.toLowerCase()}) and got a hand on the ball.`}]:[]),
          {msg:"receiver couldn't hold on",why:"The receiver couldn't hang onto the ball ‚Äî the throw was slightly off target."},
        ]:[
          {msg:"ball sails high",why:"Pressure forced a bad throw ‚Äî the ball went over the receiver's head."},
          {msg:"pass hits turf",why:"QB couldn't set his feet under pressure ‚Äî the ball bounced short."},
          ...(defClose?[{msg:"CB bats it away",why:`The cornerback was in tight coverage (${pr.op.lab.toLowerCase()}) and got a hand on it.`}]:[]),
          {msg:"can't haul it in",why:"The receiver couldn't secure the catch ‚Äî ball was slightly off target."},
        ];
        const r=pick(reasons);
        return {ok:false,int:false,yds:0,msg:`Incomplete ‚Äî ${r.msg}`,tP:rP,reason:r.why};
      }
      return {ok:true,int:false,yds:Math.round(rP.y),cId:recId,msg:`${recId.toUpperCase()} makes the catch!`,tP:rP,reason:`${recId.toUpperCase()} was ${pr.op.lab.toLowerCase()} ‚Äî good read.`};
    }

    function computeRunArrows(bcPos, defP, gameState, moveNum, carrier, holeData, diff) {
      moveNum = moveNum || 0;
      if (!bcPos) return [];
      // Speed factor by ball carrier position
      const speedFactor = carrier==="wr1"||carrier==="wr2" ? 1.0 : carrier==="rb" ? 0.9 : carrier==="te" ? 0.7 : carrier==="qb" ? 0.75 : 0.85;
      const arrows = [];
      const defenders = Object.entries(defP).map(([id,p])=>({id,...p,d:dst(bcPos,p)})).sort((a,b)=>a.d-b.d);
      const ahead = defenders.filter(d => d.y > bcPos.y - 2 && d.d < 25);

      // Distance-weighted base percentage helper
      const distBasePct = (nearDist, defCount) => {
        let base;
        if (nearDist >= 10) base = 90 + rnd(0,5);       // 90-95%
        else if (nearDist >= 6) base = 75 + rnd(0,10);   // 75-85%
        else if (nearDist >= 3) base = 50 + rnd(0,20);   // 50-70%
        else base = 20 + rnd(0,30);                       // 20-50%
        // Defender count adjustment ‚Äî matters less at long range
        const countPen = nearDist >= 8 ? defCount * 2 : nearDist >= 5 ? defCount * 4 : defCount * 6;
        return cl(base - countPen - moveNum * 8, 5, 98);
      };

      // Find nearest defender in a given direction cone
      const nearestInCone = (targetX, targetY, coneRad) => {
        const pathAngle = Math.atan2((targetX - bcPos.x) * 0.533, targetY - bcPos.y);
        let minDist = 30, count = 0;
        for (const d of ahead) {
          if (d.y <= bcPos.y) continue;
          const defAngle = Math.atan2((d.x - bcPos.x) * 0.533, d.y - bcPos.y);
          const angleDiff = Math.abs(defAngle - pathAngle);
          if (angleDiff < coneRad) {
            if (d.d < minDist) minDist = d.d;
            if (d.d < 12) count++;
          }
        }
        return { dist: minDist, count };
      };

      // Determine field state from nearest defender ahead
      const nearestAhead = ahead.filter(d => d.y > bcPos.y).sort((a,b) => a.d - b.d)[0];
      const nearDist = nearestAhead ? nearestAhead.d : 30;
      const isOpen = nearDist >= 8;      // Open field
      const isContested = nearDist >= 3;  // Contested (3-8 yards)
      // Under 3 yards = crowded, handled by contact system

      // === SPRINT ‚Äî always straight upfield ===
      const sprintTargetX = cl(bcPos.x, 5, 95); // straight ahead
      const sprintTargetY = bcPos.y + 8;
      const sprintCone = nearestInCone(sprintTargetX, sprintTargetY, 0.4);
      let sprintPct = distBasePct(sprintCone.dist, sprintCone.count);
      // Hole awareness: boost Sprint if aligned with designed hole
      let holeAligned = false;
      if (holeData && holeData.x != null) {
        const holeDx = Math.abs(bcPos.x - holeData.x);
        if (holeDx < 15) { sprintPct = cl(sprintPct + 18, 5, 98); holeAligned = true; }
        // Wider holes (better blocking / good MX) get extra boost
        if (holeAligned && holeData.width > 10) sprintPct = cl(sprintPct + 10, 5, 98);
      }
      const sprintYds = cl(Math.round(sprintCone.dist * 0.6), 2, 6);
      arrows.push({
        type: "sure", label: "Sprint", sub: holeAligned ? `~${sprintYds} yards, through the hole` : `~${sprintYds} yards, straight ahead`,
        targetX: sprintTargetX, targetY: sprintTargetY, color: "#22c55e", pct: sprintPct,
        ydsLow: sprintYds - 1, ydsHigh: sprintYds + 2
      });

      // === CUT OUTSIDE ‚Äî angle toward nearer sideline ===
      const nearerSideline = bcPos.x <= 50 ? 5 : 95;
      const cutX = cl(bcPos.x + (nearerSideline < 50 ? -18 : 18), 5, 95);
      const cutY = bcPos.y + 5;
      const cutCone = nearestInCone(cutX, cutY, 0.45);
      let cutPct = distBasePct(cutCone.dist, cutCone.count);
      // Slight penalty to Cut Outside when hole is designed elsewhere
      if (holeAligned) cutPct = cl(cutPct - 5, 5, 98);
      const cutYds = cutCone.dist >= 8 ? rnd(6, 12) : rnd(3, 8);
      if (!isOpen || true) { // always show Cut Outside (suppressed for Juke below)
        arrows.push({
          type: "gamble", label: "Cut Outside", sub: `${cutYds} yards if clear, risky`,
          targetX: cutX, targetY: cutY, color: "#fbbf24", pct: cutPct,
          ydsLow: cutCone.dist >= 8 ? 4 : 0, ydsHigh: cutYds
        });
      }

      // === JUKE ‚Äî only in contested range (nearest 3-8 yards), suppressed in open field ===
      if (!isOpen) {
        const hrX = bcPos.x < 50 ? cl(bcPos.x + 20, 10, 90) : cl(bcPos.x - 20, 10, 90);
        const hrCone = nearestInCone(hrX, bcPos.y + 20, 0.5);
        const hrPct = cl(distBasePct(hrCone.dist, hrCone.count) * 0.35, 5, 25);
        arrows.push({
          type: "homerun", label: "Juke", sub: `Low odds, huge gain`,
          targetX: hrX, targetY: bcPos.y + 20, color: "#ef4444", pct: hrPct,
          ydsLow: -2, ydsHigh: 40
        });
      }

      // === DIVE FORWARD ‚Äî always available, shown via getRunActions ===
      // (Dive Forward is added in getRunActions, not here)

      // Apply speed factor ‚Äî slower carriers (TE, QB) get reduced arrow percentages
      for (const a of arrows) a.pct = cl(Math.round(a.pct * speedFactor), 5, 98);

      // Difficulty modifier ‚Äî easier difficulties get run forgiveness
      const diffBonus = diff==="practice" ? 20 : diff==="preseason" ? 12 : diff==="playoffs" ? -5 : 0;
      if (diffBonus !== 0) for (const a of arrows) a.pct = cl(a.pct + diffBonus, 5, 98);

      return arrows;
    }

    // ==================== COACH DIALOGUE MATRIX ====================
    function coachPresnap(scheme, play, mxRating, gameState, cType) {
      const pName = play.name;
      if (cType === "A") {
        if (mxRating >= 1) return `They're in ${scheme.name}. ${pName} is exactly what tears this apart. Execute, my grandmother could score on this.`;
        if (mxRating === 0) return `They're showing ${scheme.name}. ${pName} works if you don't mess it up. Your call.`;
        return `Are you blind? They're in ${scheme.name}. ${pName} is suicide here. Audible out of it unless you want to get hit.`;
      } else {
        if (mxRating >= 1) return `Good read. They're showing ${scheme.name}, and ${pName} is a great counter. Trust the play.`;
        if (mxRating === 0) return `${scheme.name} defense. ${pName} is a fair matchup. Execute and we'll be fine.`;
        return `Careful here. They're in ${scheme.name}, which is built to stop ${pName}. I'd strongly consider an audible.`;
      }
    }

    function coachQB(ph, offP, defP, mu, scheme, lookDir, cType, diff) {
      const pi = getPocket(mu), weak = getWeak(mu);
      if (pi < 20) return isPre(diff)?"Your blockers can't hold much longer ‚Äî throw to someone or tuck the ball!":(cType === "A" ? "Pocket's dead! Get rid of it now!" : "Pressure's here, make a decision or scramble!");
      if (pi < 40 && weak.int < 10) return isPre(diff)?`Your blocker on the ${weak.id === "de1" ? "left" : "right"} is getting pushed back. Move away from that side or throw soon!`:(cType === "A" ? `Your ${gP(OFF,weak.id)?.lab} is getting embarrassed. Move!` : `Protection breaking down on the ${weak.id === "de1" ? "left" : "right"}. Step up or roll out.`);

      for (const id of ["wr1","wr2","te","rb"]) {
        const o = opn(id, offP, defP, scheme);
        if (o.o >= 3 && offP[id]?.y > 8) return isPre(diff)?`üëÅÔ∏è ${fmtTarget(id)} is wide open! Throw to them now!`:(cType === "A" ? `üëÅÔ∏è ${id.toUpperCase()} is wide open! What are you waiting for, an invitation?` : `üëÅÔ∏è ${id.toUpperCase()} has a step! Hit him!`);
      }

      if (lookDir) return isPre(diff)?`The deep defenders moved ${lookDir}. Now look the other way ‚Äî receivers on that side should be more open!`:(cType === "A" ? `Safeties bit ${lookDir}. Look back to the open side and fire.` : `Safeties shifted ${lookDir}. Read the opposite side.`);
      return isPre(diff)?"Good protection. Your receivers are still running their routes ‚Äî drop back to give them more time, or throw if someone's open.":(cType === "A" ? "Pocket's clean. Let the deep routes cook." : "Good protection. Let the play develop and make your read.");
    }

    function coachRunner(bcPos, defP, arrows, gameState, cType) {
      if (!bcPos) return "";
      const nd = nearD(bcPos, defP);
      if (nd.d < 3) return cType === "A" ? `Make him miss! Don't let him tackle you here!` : `Defender closing fast, secure the ball and make a move!`;
      const sure = arrows.find(a => a.type === "sure");
      if (sure && sure.targetX) return cType === "A" ? `Hit the gap for free yards. Don't dance around.` : `Follow your blocks into the gap for steady yardage.`;
      return cType === "A" ? "Open field! Turn on the jets!" : "You've got room, get north and south!";
    }

    function coachContact(bcPos, defP, d3, cType) {
      if (d3 >= 3) return cType === "A" ? "You're swarmed. Fall forward and don't do anything stupid." : "Multiple defenders. Protect the ball and live for the next down.";
      if (d3 === 1) return cType === "A" ? "One-on-one. Spin off him and make a highlight." : "One man to beat. Trust your feet.";
      return cType === "A" ? "Hit 'em hard." : "Contact imminent. Keep the legs churning.";
    }

    function postPlayDebrief(result, play, scheme, mu, diff) {
      if (!result || !play || !scheme) return "";
      const defName = scheme.name, playName = play.name, mxR = MX[playName]?.[scheme.key] || 0;
      if (result.reason) return result.reason;
      if (result.turnover) return isPre(diff)?`Turnover on ${playName}. ${mxR < 0 ? "That defense was set up to stop this play ‚Äî next time, look for a play with a green matchup rating." : "Bad luck ‚Äî the play call was fine, it just didn't go your way."}`:`Turnover on ${playName} vs ${defName}. ${mxR < 0 ? "The matchup was against us ‚Äî consider a different play next time against this defense." : "Bad luck ‚Äî the play call was fine."}`;
      if (result.yds <= 1 && !result.incomplete) {
        if (mxR <= -1) return isPre(diff)?`${playName} struggled because ${defName} is built to stop it. Look at the matchup colors ‚Äî green means your play has an advantage.`:`${playName} was a tough call against ${defName} ‚Äî they were set up to stop exactly this. Look for plays with a better matchup rating.`;
        const weak = getWeak(mu);
        if (weak.int < 20) return isPre(diff)?`Your blocker (${gP(OFF,weak.id)?.lab||"lineman"}) got pushed back and the defenders got through. The play itself was fine, but the blocking broke down.`:`Your ${gP(OFF,weak.id)?.lab||"lineman"} lost his matchup and the defense got through. The play design was fine, the blocking broke down.`;
        return isPre(diff)?"The defense made a good play ‚Äî sometimes they just win. Nothing you did wrong.":"Defense made a good play ‚Äî sometimes they just win the rep.";
      }
      if (result.yds >= 15) return `Big play! ${mxR >= 1 ? "Good read ‚Äî the matchup was in your favor and you exploited it." : "Great execution ‚Äî that worked despite a tough matchup."}`;
      return "";
    }

    // ==================== SUCCESS COACHING ‚Äî WHY IT WORKED ====================
    const SUCCESS_COACHING = {
      cover2: [
        "That's exactly how you attack Cover 2 ‚Äî both safeties dropped deep and your receiver found the soft spot in the middle.",
        "Cover 2 gives up the short-to-intermediate middle. You saw it and took what they gave you.",
        "When both safeties play deep like that, the underneath routes are wide open. Smart read.",
        "Cover 2 protects deep but can't cover everything short. You exploited the gap between the zones.",
      ],
      base43: [
        "Base 4-3 is balanced, but that means it's not great at anything. You found the seam in their coverage.",
        "The linebackers in 4-3 have to choose between run and pass ‚Äî your play made them guess wrong.",
        "Nice read ‚Äî 4-3 Base drops the LBs into zones, but they can't cover the whole middle. You threaded it.",
        "That's steady football against a balanced defense. The 4-3 doesn't blitz, so you had time to find the open man.",
      ],
      nickel: [
        "Nice read ‚Äî Nickel puts an extra DB on the receivers but leaves the middle soft for the TE or RB.",
        "Nickel pulls a linebacker for a defensive back ‚Äî that weakens the run defense and the short middle. You took advantage.",
        "The extra DB in Nickel covers the outside, but it creates a soft spot underneath. Good recognition.",
        "Nickel sacrifices size for speed. When you run power or find the middle, they can't match up physically.",
      ],
      blitz: [
        "The blitz sent extra rushers but left fewer defenders in coverage ‚Äî your quick read punished them.",
        "Play Action froze the linebackers ‚Äî they bit on the fake and your receiver ran right past them.",
        "When they blitz, they're gambling that the rush gets there before you throw. You got the ball out in time.",
        "Blitz means fewer defenders in coverage. You stayed calm under pressure and found the open window.",
      ],
      goalline: [
        "Goal line defense packs the box but has zero help deep. You found the weakness and exploited it.",
        "They sold out to stop the short game and left the outside or deep routes wide open. Great call.",
        "Goal line puts everyone at the line ‚Äî if you get past the first wave, there's nobody behind them.",
        "That's the risk of Goal Line defense ‚Äî stop the run at all costs, but leave yourself exposed if they pass or bounce outside.",
      ],
    };

    // ==================== COMMENTARY SYSTEM ‚Äî DAN & KIKI ====================
    const fmtTarget=id=>{if(id==="wr1")return"W1";if(id==="wr2")return"W2";if(id==="te")return"TE";if(id==="rb")return"RB";return(id||"").toUpperCase();};

    // DAN: play-by-play, factual. KIKI: color commentary, personality/analysis.
    // Each category has {dan:[...], kiki:[...], kikiTeach:[...]}
    // kikiTeach is used in Practice/Preseason; kiki in Regular/Playoffs
    const DK = {
      passCompBig: {
        dan:["Complete to {target} on the {play}, gain of {yards}. First down.","Strike to {target} for {yards} yards! Big play on the {play}.","Pass complete to {target} ‚Äî {yards}-yard pickup. Chains are moving.","What a throw to {target}! {yards} yards downfield, beat the safety over the top.","Fires to {target}, who breaks free for {yards}. That'll move the chains!","On the money to {target}! {yards} yards through the air, cornerback had no chance.","Dime! {target} hauls it in for {yards} on the {play}. Linebacker was stuck in no-man's land.","Perfect ball to {target} ‚Äî {yards}-yard completion past the safety. First down and then some."],
        kiki:["That's how you beat {def} ‚Äî find the soft spot and deliver.","When you hit throws like that, the cornerback just has to tip his hat.","That ball was out before the safety could close. Perfect timing.","Ice in the veins on that one. Dropped it in a window between the linebacker and cornerback.","You can see the QB's confidence growing. That was a statement throw.","The cornerback didn't even have time to turn around. Elite ball placement.","I love that throw. Anticipation, not reaction. The safety was a step late and it cost them.","Textbook. Read the coverage, found the gap between the linebackers, delivered on time."],
        kikiTeach:["The {play} created a mismatch against {def} ‚Äî {target} found the gap in the zone and the QB delivered on time.","Notice how {target} got behind the coverage? That's what happens when you let the route develop before throwing.","Great read. The defense was in {def}, which leaves that area open. You recognized it and made the right throw.","That throw worked because {target} had separation. In football, waiting one more beat for the route to develop makes all the difference."]
      },
      passCompShort: {
        dan:["Quick throw to {target} for {yards}. Keeps the chains moving.","Pass to {target}, gain of {yards}. Underneath the linebackers. Solid.","Finds {target} for {yards} on the {play}. Dump-off in the flat, nothing flashy.","Gets it to {target} for a {yards}-yard gain. Quick release before the rush gets there.","Underneath to {target}. {yards} yards, the linebacker couldn't get there in time.","Check-down to {target} for {yards}. Running back found space in the flat.","Hits {target} in stride for {yards}. Quick pass under the safety.","Short completion to {target}. {yards} yards before the cornerback can close."],
        kiki:["Take what the defense gives you. The linebackers dropped deep and left the short stuff open.","You don't need the home run every play. That's a first down throw underneath the coverage.","Short and sweet. Keeps the defense honest ‚Äî they can't just rush every play.","Quick throw to the flat ‚Äî the linebacker couldn't get there in time. Smart football.","Boring? Maybe. Effective? Absolutely. That's how you sustain drives.","Sometimes the smartest QB in the room is the one throwing 5-yard completions under the linebackers all day.","I'll take those completions 10 times out of 10. Move the chains, keep possession.","That's called being a professional. The safety was deep, so take the easy yards underneath."],
        kikiTeach:["That was a safe, smart read. Against {def}, the short route to {target} was there all day.","Sometimes the best play is the easy one. {target} was open underneath and you took the easy yards.","Good decision. When the deep routes are covered, checking down to {target} keeps the drive alive.","That's what you want ‚Äî quick read, quick throw, easy yards. No need to force it deep."]
      },
      passIncWideOpen: {
        dan:["Pass to {target} is incomplete. He was wide open.","Dropped! {target} couldn't bring it in. Ball was right there.","Incomplete ‚Äî {target} had his man beat and put it on the ground.","Wide open {target} can't haul it in. Drive stalls.","Receiver drops it! {target} was standing there alone.","Off his hands! {target} had nothing but green around him.","Can't bring it in! {target} had the first down and more.","Incomplete! {target} was wide open but couldn't hold on."],
        kiki:["Can't drop those. That's a drive-killer.","Receiver has to make that catch. No excuses.","That was gift-wrapped and he fumbled the ribbon.","You made the right read. Sometimes the football gods just say no.","I've seen Pop Warner receivers make that catch. Come on.","The QB did everything right. The receiver let him down on that one.","That's the kind of drop that makes a coach lose sleep.","Hey, even the pros drop 'em. But that one stings."],
        kikiTeach:["The good news: your read was perfect. {target} was wide open. The bad news: drops happen. Keep making that same read ‚Äî it'll connect.","That was the right throw to the right spot. The drop isn't your fault ‚Äî keep looking for {target} in that situation.","Your decision-making was correct. {target} had separation. In real football, drops happen even to the best receivers.","Don't let the drop change your approach. You read {def} correctly and found the open man."]
      },
      passIncContested: {
        dan:["Pass to {target} is incomplete. Good coverage.","Incomplete to {target}. Tight window, tough throw.","Batted away! {target} couldn't separate.","Thrown to {target} in traffic ‚Äî falls incomplete.","Incomplete. The DB made a play on the ball.","Pass to {target} is broken up. Defender was step for step.","Can't connect with {target}. Too much traffic.","Incomplete ‚Äî {target} and the DB both went for it. Nobody came down with it."],
        kiki:["Tight coverage. You're throwing into traffic there.","The DB was right on his hip. That's a low-percentage throw.","Sometimes the defense just makes a play.","Contested throws are 50/50 at best. Pick your spots.","That's a tough window. Even the best QBs miss that throw sometimes.","I counted two defenders in the area. That's not a window, that's a wall.","The coverage was just too tight. Find the open man instead.","Props to the DB on that one. Textbook coverage."],
        kikiTeach:["That throw was contested because {target} didn't have enough separation against {def}. Try waiting another beat for the route to develop.","Against {def}, the defenders were in good position on {target}. Look for receivers with more space ‚Äî check the openness labels.","Contested throws are risky. In {def}, the DBs are tight on the outside. Look for the TE or RB underneath.","When you see 'Contested' on a receiver, that means the defender is close. Try looking for someone with more separation."]
      },
      passIncCovered: {
        dan:["Forced it to {target} ‚Äî incomplete. Covered all the way.","Incomplete. {target} was blanketed by the defense.","Pass to {target} falls incomplete. No separation.","Can't get it to {target}. Defense had it covered.","Incomplete ‚Äî {target} never had a chance to get open.","Pass attempt to {target} is knocked away. DB was all over it.","Forces it to {target} ‚Äî falls incomplete. Dangerous throw.","No chance. {target} had a defender draped on him."],
        kiki:["That's forcing it. The defender was all over that route.","You can't throw into that coverage and expect good things.","When a receiver is covered, throw it away. Live to play another down.","The defense read that coming from the snap.","Lucky that wasn't picked. That ball had no business going there.","That's a 'hero ball' throw. Nobody's impressed by it working 1 out of 10 times.","The defender knew where that ball was going before the receiver did.","File that under 'throws you wish you could take back.'"],
        kikiTeach:["That route was covered by {def}. When you see 'Covered' on a receiver, that means the defender has position ‚Äî don't throw there.","Against {def}, that receiver wasn't going to get open. Try dropping back more to give the routes time to develop, or look for a different target.","The defense had {target} locked down. Next time, look at the openness labels ‚Äî green means open, red means stay away.","Forcing throws into tight coverage is the number one cause of interceptions. Be patient and find the open man."]
      },
      interception: {
        dan:["INTERCEPTED! The cornerback comes up with the ball.","Picked off by the safety! That's a turnover.","Interception! {def} ‚Äî the cornerback was sitting on that route.","That ball is intercepted by the safety! Change of possession.","Oh no! Intercepted! The cornerback jumped the route.","INT! The linebacker dropped into coverage and picked it off.","Picked! The safety had it read the whole way.","Intercepted at the catch point by the cornerback! Turnover!"],
        kiki:["That's the throw you can't make. The cornerback was waiting.","The safety read his eyes and jumped the route. Backbreaking.","Right into the defender's hands. The cornerback had perfect position.","When the defense shows {def}, that throw is a trap. The safety was baiting it.","That's a gift. The cornerback didn't earn that one ‚Äî it was handed to them.","Throw it away! Throw it away! The safety was right there!","The safety was cheating over there the whole time. Had to see that.","The linebacker dropped into a zone and the QB never saw him. Momentum killer."],
        kikiTeach:["The defender was in position because {def} takes away that route. Before throwing, check if the receiver shows 'Open' ‚Äî if not, look elsewhere or throw it away.","That interception happened because the ball hung too long. Against {def}, the safety was in position to jump that throw.","Interceptions usually happen when you throw to a covered receiver. Against {def}, try looking for the receivers who have more separation.","Key lesson: throwing into coverage is the riskiest thing you can do. When in doubt, throw it away or tuck the ball."]
      },
      sack: {
        dan:["SACKED! The defensive end got around the tackle. Loss of {yards}.","He's brought down behind the line! The linebacker got through. Sack, loss of {yards}.","Down he goes! The defensive end beat the blocker and the pressure got home.","Couldn't escape the rush. The defensive tackle pushed the pocket. Sack.","The rush gets there! Defensive end comes off the edge ‚Äî QB is down, loss of {yards}.","Sacked for a loss of {yards}! The left tackle got beat and protection broke down.","He's buried! The defensive line wins that one. End and tackle collapsed the pocket.","QB goes down! The linebacker came on the blitz untouched. {yards}-yard loss."],
        kiki:["Held it too long. The defensive end was coming and the pocket doesn't wait forever.","Can't stand back there that long ‚Äî the pass rushers will find you.","When the pocket collapses, get rid of it. The defensive end was already past your tackle.","The defensive line won their matchups. Time to make quicker decisions.","The clock in his head needs to speed up. The edge rushers are too fast to hold that long.","You had time. You had a window. The defensive end closed it and now you have a sack.","That's what happens when you play hero ball. The pass rush always wins if you hold it.","The offensive line gave him time ‚Äî he just didn't use it before the rush arrived."],
        kikiTeach:["That sack happened because the pocket collapsed while you were deciding. Watch the pocket bars ‚Äî when they go red, throw the ball or tuck it.","Against {def}, the pass rush is coming fast. You need to make quicker reads and get the ball out early.","Sacks lose more yardage than incompletions. When in doubt, throw it away ‚Äî it's incomplete, but you keep the yards.","The key to avoiding sacks: drop back, read quickly, and if nobody's open, tuck the ball or throw it away before the rush gets there."]
      },
      runBig: {
        dan:["Handoff to the running back ‚Äî breaks free for {yards}! Big run!","He finds the hole and he's GONE! {yards}-yard gain! Linebackers couldn't get there!","{yards} on the ground! The safety had to come up and missed the tackle!","Takes the handoff and rips off {yards} yards past the linebackers!","Burst through the line for {yards}! The defensive linemen got pushed back!","Hits the gap ‚Äî {yards} yards! Ran right past the linebacker. That's a chunk play.","What a run! {yards} yards on the {play}! The cornerback had to make the tackle.","Breaks a tackle from the linebacker and he's off for {yards}! Huge gain!"],
        kiki:["Hit the gap and the linebackers couldn't catch him. That's running.","The offensive line created a lane and the running back hit it perfectly.","THAT's what a run game looks like ‚Äî the linebackers were out of position.","When you pick the right play against the right defense, the linebackers can't fill the gaps.","That offensive line is moving the defensive linemen off the ball. Love to see it.","He made one cut past the linebacker and hit the jets. Vision AND speed.","THAT is why you establish the run. The linebackers have to respect it, which opens up the pass.","The linebackers dropped into coverage and the running back made them pay. Beautiful."],
        kikiTeach:["That big run happened because the {play} was effective against {def}. The matchup was in your favor and the blockers opened a lane.","Great play call. The {play} found the gap because {def} wasn't set up to stop it. Watch the matchup arrows ‚Äî green means the play is strong.","Big runs come from good play selection. You picked the right call against this defense and the blockers did their job.","That gap opened because {def} is vulnerable to the run. Keep attacking when you see a favorable matchup."]
      },
      runShort: {
        dan:["Handoff, gets {yards} on the {play}. Linebacker made the stop. Tough running.","Gain of {yards} on the ground. Defensive end forced it back inside.","Grinds out {yards} yards on the {play}. Safety came up to help on the tackle.","Takes it for {yards}. Linebacker filled the gap. Hard-fought yardage.","Picks up {yards} on the {play}. Nothing extra, but it's a gain before the linebacker gets there.","Gain of {yards}. The defensive line limits the damage.","{yards} yards on the carry. Cornerback had to come up and make the tackle.","Short gain of {yards} on the {play}. Linebacker meets him at the line. Physical football."],
        kiki:["Not flashy, but it moves the sticks. The linebacker made a good play to limit it.","Steady running. The linebackers are having to work for every tackle.","Three yards and a cloud of dust. That's football ‚Äî the defensive line can't hold forever.","Keep pounding it. Those linebackers are getting tired and the big one will come.","Ugly? Sure. But it's {yards} more than the defense wanted to give up.","He'll take those carries all day. Wears the linebackers down.","Every carry like that is a win for the offense. The defensive line can't sustain this.","That's called running behind your pads. The safety had to come up to help ‚Äî that opens the deep ball."],
        kikiTeach:["Solid gain. The {play} got {yards} yards against {def} ‚Äî that's good, steady football.","Short runs still move the chains. Against {def}, the run game is working ‚Äî keep using it.","The defense held it to a short gain, but {yards} yards still helps. Watch the down and distance.","Consistent runs tire out the defense. Keep mixing in the run when the matchup is decent."]
      },
      runLoss: {
        dan:["Stuffed at the line! Linebacker shot the gap. No gain on the {play}.","Handoff and the defensive end is in the backfield. Loss of yardage.","Nowhere to go. Linebackers filled every gap.","Hit behind the line. The defensive tackle pushed through. Defense read that perfectly.","Tackled in the backfield by the linebacker! Defense blew that up.","The linebacker was there before the running back. No chance.","Run stuffed. The defensive line won at the point of attack.","Hit at the line of scrimmage. Defensive end and linebacker collapsed the hole."],
        kiki:["Linebackers had that read from the snap. They were in the gaps before the handoff.","That play ran right into the teeth of the defensive line.","Can't run into a stacked box ‚Äî the linebackers are just sitting there waiting for it.","The linebacker was in the right spot. Gotta adjust.","The defensive end crashed inside. They knew it was coming.","The defensive tackle split the double team. Sometimes they just win up front.","That play needs the linebackers out of position to work. Adjust the game plan.","The defensive coordinator earned his paycheck on that one. Linebackers were perfect."],
        kikiTeach:["That run was stuffed because {def} was in position to stop the {play}. Check the matchup arrow ‚Äî red or yellow means the defense has an advantage.","The defense read the run and filled the gaps. Against {def}, the {play} is a tough matchup ‚Äî try a different run or go to the passing game.","When the defense sells out to stop the run, that's when play action works. If runs keep getting stuffed, try a pass play.","Key lesson: running into a bad matchup usually means lost yardage. Watch the matchup indicators before picking your play."]
      },
      touchdown: {
        dan:["TOUCHDOWN! {yards} yards into the end zone!","He's IN! Touchdown! What a play!","TOUCHDOWN! Nobody catching him!","Across the goal line! TOUCHDOWN!","SIX! He scores! {yards}-yard TOUCHDOWN!","INTO THE END ZONE! Touchdown!","That's a TOUCHDOWN! What a drive!","He breaks the plane! TOUCHDOWN! {yards} yards!"],
        kiki:["That is a BEAUTIFUL play call. Executed to perfection.","Cashed it in! That's what you play for.","When the play call and the execution come together, THAT happens.","You can't defend that. Perfect read, perfect execution.","Give that QB a raise! That was ice-cold execution.","I've been doing this a long time and that play call was chef's kiss.","THAT is the definition of a good drive. Every play built on the last one.","The defense had no chance. They knew what was coming and still couldn't stop it."],
        kikiTeach:["Touchdown! You read the defense correctly and made the right play. That's what smart football looks like.","That score came from a good decision against {def}. Remember what worked here ‚Äî the same read will work again.","Beautiful drive! You combined good play calls with smart reads. That's how you consistently score.","Touchdown! Notice how each good decision earlier in the drive led to this moment. That's the game."]
      },
      throwAway: {
        dan:["Throws it away. Incomplete, no gain.","Tosses it out of bounds. Smart decision.","Sails it into the dirt. Lives to fight another down.","Throw away. No harm done.","Fires it into the stands. No harm, no foul.","Throws it at the cheerleaders. Well, near them anyway.","Gets rid of it. Incomplete by design.","Smart throw-away. Protects the football."],
        kiki:["Smart. Nobody open, get rid of it.","Better than a sack. Better than a pick. No shame in that.","When the cupboard's bare, throw it away. Football IQ.","Discretion is the better part of valor there.","The best throw you can make is sometimes the one you don't.","High football IQ right there. I respect that decision every time.","A throw-away is zero yards lost. A sack is five. I'll take zero.","That's a veteran move. Protect the drive, live for the next play."],
        kikiTeach:["Good decision! When nobody is open, throwing it away is the smartest play. You keep the ball and only lose one down.","That's exactly right. Against {def}, nobody had separation, so throwing it away was better than forcing it into coverage.","Smart play. Throwing it away saves you from sacks and interceptions. You'll get a better look next play.","Great football IQ. The best QBs know when to throw it away instead of forcing a bad throw."]
      },
      fumble: {
        dan:["FUMBLE! Ball is on the ground! Defense recovers!","He loses it! Fumble! Turnover!","Ball comes loose! Fumble recovered by the defense!","AND IT'S A FUMBLE! Change of possession!","Strips the ball! Fumble! Defense has it!","Ball is out! Fumble recovered by the defense!","He loses the handle! That's a fumble!","The ball is on the turf! Defense recovers the fumble!"],
        kiki:["You cannot put the ball on the ground. Game-changing mistake.","Fighting for extra yards and it costs you. Know when to go down.","That's a drive-ender. Ball security has to be priority one.","The defense forced it out. That's a back-breaking turnover.","How many times do coaches say 'protect the football'? Now you know why.","That extra yard wasn't worth the risk. Dive forward and live another day.","Ball security, ball security, ball security. I sound like a broken record because it matters.","Gut-punch. All that good work on the drive, gone in an instant."],
        kikiTeach:["Fumbles happen when you try to break tackles in traffic. After the first broken tackle, the fumble risk goes WAY up. Sometimes diving forward is the safe play.","That fumble was costly. Against multiple defenders, the safe play is Dive Forward ‚Äî it doesn't have fumble risk.","Key lesson: every time you try to break a tackle, there's a fumble chance. After breaking one tackle, the odds get worse. Protect the ball.","Ball security matters most. When you see 2+ defenders closing in, dive forward and take the safe yards instead of risking a fumble."]
      },
      turnovOnDowns: {
        dan:["Turnover on downs. Defense holds.","Fourth down and they couldn't convert. Defense takes over.","Stopped on fourth down. Change of possession.","That's a turnover on downs.","Can't convert! Turnover on downs.","Fourth and done. Defense stands tall.","No conversion! The defense digs in and holds!","Turned away on fourth down. Change of possession."],
        kiki:["Going for it on fourth is gutsy, but you need to execute.","Came up short. Sometimes the defense wins.","That's a field position killer. Might've been better to punt.","Bold call, but the defense had the answer.","Fourth down gambles are only fun when they work.","Hindsight's 20/20, but a field goal would've put points on the board.","The defense smelled that coming. They loaded up and shut it down.","I respect the aggressiveness, but you have to convert those."],
        kikiTeach:["Fourth down conversions are risky. Make sure the play you pick has a favorable matchup, or consider punting or kicking a field goal.","That didn't convert because the defense was in good position. On fourth down, look for the highest-percentage play available.","Going for it on fourth is exciting but risky. When in doubt, take the points with a field goal or punt to pin them back.","Key lesson: fourth down is high-stakes. Your play call needs to be your best shot ‚Äî check matchups carefully."]
      }
    };

    function generateCommentary(res, play, scheme, game, diff, openness, lastTarget) {
      if(!res||!play||!scheme)return null;
      const vars={target:fmtTarget(lastTarget),play:play.name,def:scheme.name,yards:Math.abs(res.yds)};
      const fill=s=>s.replace(/\{target\}/g,vars.target).replace(/\{play\}/g,vars.play).replace(/\{def\}/g,vars.def).replace(/\{yards\}/g,vars.yards);
      const mxR=MX[play.name]?.[scheme.key]||0;

      // Pick category
      let cat=null;
      if(res.td) cat="touchdown";
      else if(res.turnover&&res.desc&&res.desc.includes("FUMBLE")) cat="fumble";
      else if(res.turnover) cat="interception";
      else if(res.incomplete){
        if(res.desc&&res.desc.includes("Threw it away")) cat="throwAway";
        else if(res.yds<0) cat="sack";
        else if(openness==="WIDE OPEN"||openness==="Wide Open") cat="passIncWideOpen";
        else if(openness==="CONTESTED"||openness==="Contested") cat="passIncContested";
        else cat="passIncCovered";
      } else if(res.yds<0&&!(play.type==="run"||play.qbDraw)) cat="sack";
      else if(play.type==="run"||play.qbDraw||play.statue||play.flea){
        if(res.yds>=10) cat="runBig"; else if(res.yds>=1) cat="runShort"; else cat="runLoss";
      } else {
        if(res.yds>=15) cat="passCompBig"; else cat="passCompShort";
      }

      if(!cat||!DK[cat])return null;
      const pool=DK[cat];
      // FIX 6 (14.6): No-repeat picker ‚Äî avoid same line twice in a row
      const pickNew=(arr)=>{
        if(arr.length<=1)return arr[0]||"";
        const last=generateCommentary._last||{};
        const key=arr===pool.dan?"dan":"kiki";
        let choice=pick(arr);
        let tries=0;
        while(choice===last[key]&&tries<5){choice=pick(arr);tries++;}
        if(!generateCommentary._last)generateCommentary._last={};
        generateCommentary._last[key]=choice;
        return choice;
      };
      const dan=fill(pickNew(pool.dan));
      const useTeach=isPre(diff)&&pool.kikiTeach;
      const kiki=fill(pickNew(useTeach?pool.kikiTeach:pool.kiki));

      return {dan,kiki};
    }

    function Fireworks({show}) {
      const [ps,setPs]=useState([]);
      useEffect(()=>{
        if(!show){setPs([]);return;}
        const a=[];
        for(let b=0;b<5;b++){const cx=80+Math.random()*(FW-160),cy=60+Math.random()*150;
        const c=["#fbbf24","#22c55e","#ef4444","#4a9eff","#f97316","#a855f7"][~~(Math.random()*6)];
        for(let i=0;i<18;i++){const an=(i/18)*Math.PI*2+Math.random()*0.3,sp=2+Math.random()*3;
        a.push({k:`${b}-${i}`,cx,cy,an,sp,c,dl:b*300,lf:800+Math.random()*400});}}
        setPs(a);
      },[show]);
      if(!show||!ps.length)return null;
      return(<div style={{position:"absolute",inset:0,zIndex:50,pointerEvents:"none",overflow:"hidden"}}>
        {ps.map(p=>(<div key={p.k} style={{position:"absolute",left:p.cx,top:p.cy,width:6,height:6,borderRadius:"50%",
          background:p.c,boxShadow:`0 0 6px ${p.c}`,animation:`fw ${p.lf}ms ease-out ${p.dl}ms forwards`,
          "--dx":`${Math.cos(p.an)*p.sp*30}px`,"--dy":`${Math.sin(p.an)*p.sp*30}px`}}/>))}
      </div>);
    }

    // ==================== SOUND EFFECTS (Web Audio API) ====================
    let _sfxCtx=null;
    function sfxCtx(){
      if(!_sfxCtx)_sfxCtx=new(window.AudioContext||window.webkitAudioContext)();
      if(_sfxCtx.state==="suspended")_sfxCtx.resume();
      return _sfxCtx;
    }
    const SFX={
      // FIX 4 (15.2.1): UI tick ‚Äî short dry percussive click, no pitch sweep
      tick(ctx){
        const t=ctx.currentTime;
        // Short noise burst ‚Äî percussive pop like tapping a physical button
        const len=Math.floor(ctx.sampleRate*0.025),buf=ctx.createBuffer(1,len,ctx.sampleRate),d=buf.getChannelData(0);
        for(let i=0;i<len;i++)d[i]=(Math.random()*2-1)*Math.max(0,1-i/(len*0.4));
        const s=ctx.createBufferSource(),g=ctx.createGain(),bp=ctx.createBiquadFilter();
        s.buffer=buf;bp.type="bandpass";bp.frequency.value=500;bp.Q.value=0.8;
        s.connect(bp);bp.connect(g);g.connect(ctx.destination);
        g.gain.setValueAtTime(0.08,t);
        g.gain.exponentialRampToValueAtTime(0.001,t+0.025);
        s.start(t);s.stop(t+0.03);
      },
      // FIX 3 (15.1.1): Improved snap ‚Äî punchy pop, less buzzy
      snap(ctx){
        const t=ctx.currentTime;
        // Sharp attack pop
        const o1=ctx.createOscillator(),g1=ctx.createGain();
        o1.connect(g1);g1.connect(ctx.destination);
        o1.type="triangle";o1.frequency.setValueAtTime(300,t);
        o1.frequency.exponentialRampToValueAtTime(60,t+0.04);
        g1.gain.setValueAtTime(0.35,t);
        g1.gain.exponentialRampToValueAtTime(0.001,t+0.06);
        o1.start(t);o1.stop(t+0.06);
        // Noise transient for leather texture
        const len=Math.floor(ctx.sampleRate*0.03),buf=ctx.createBuffer(1,len,ctx.sampleRate),d=buf.getChannelData(0);
        for(let i=0;i<len;i++)d[i]=(Math.random()*2-1)*Math.max(0,1-i/len);
        const s=ctx.createBufferSource(),gn=ctx.createGain(),hp=ctx.createBiquadFilter();
        s.buffer=buf;hp.type="highpass";hp.frequency.value=800;
        s.connect(hp);hp.connect(gn);gn.connect(ctx.destination);
        gn.gain.setValueAtTime(0.15,t);
        gn.gain.exponentialRampToValueAtTime(0.001,t+0.04);
        s.start(t);s.stop(t+0.04);
      },
      // FIX 3 (15.1.1): Improved tackle ‚Äî deep thud with body impact feel
      tackle(ctx){
        const t=ctx.currentTime;
        // Deep sub-bass thud
        const o1=ctx.createOscillator(),g1=ctx.createGain();
        o1.connect(g1);g1.connect(ctx.destination);
        o1.type="sine";o1.frequency.setValueAtTime(55,t);
        o1.frequency.exponentialRampToValueAtTime(20,t+0.18);
        g1.gain.setValueAtTime(0.4,t);
        g1.gain.exponentialRampToValueAtTime(0.001,t+0.22);
        o1.start(t);o1.stop(t+0.22);
        // Impact transient ‚Äî short filtered noise burst
        const len=Math.floor(ctx.sampleRate*0.05),buf=ctx.createBuffer(1,len,ctx.sampleRate),d=buf.getChannelData(0);
        for(let i=0;i<len;i++)d[i]=(Math.random()*2-1)*Math.max(0,1-i/len);
        const s=ctx.createBufferSource(),gn=ctx.createGain(),lp=ctx.createBiquadFilter();
        s.buffer=buf;lp.type="lowpass";lp.frequency.value=400;lp.Q.value=1;
        s.connect(lp);lp.connect(gn);gn.connect(ctx.destination);
        gn.gain.setValueAtTime(0.2,t);
        gn.gain.exponentialRampToValueAtTime(0.001,t+0.06);
        s.start(t);s.stop(t+0.06);
      },
      // FIX 3 (15.1.1): Improved crowd ‚Äî swelling roar, less static
      crowd(ctx){
        const t=ctx.currentTime;
        const len=Math.floor(ctx.sampleRate*0.5),buf=ctx.createBuffer(1,len,ctx.sampleRate),d=buf.getChannelData(0);
        for(let i=0;i<len;i++)d[i]=Math.random()*2-1;
        const s=ctx.createBufferSource(),g=ctx.createGain();
        const bp=ctx.createBiquadFilter(),lp=ctx.createBiquadFilter();
        s.buffer=buf;
        bp.type="bandpass";bp.frequency.setValueAtTime(600,t);
        bp.frequency.linearRampToValueAtTime(1800,t+0.15);
        bp.frequency.linearRampToValueAtTime(1200,t+0.4);bp.Q.value=0.8;
        lp.type="lowpass";lp.frequency.value=3000;
        s.connect(bp);bp.connect(lp);lp.connect(g);g.connect(ctx.destination);
        g.gain.setValueAtTime(0.02,t);
        g.gain.linearRampToValueAtTime(0.22,t+0.12);
        g.gain.setValueAtTime(0.22,t+0.25);
        g.gain.exponentialRampToValueAtTime(0.001,t+0.5);
        s.start(t);s.stop(t+0.5);
      },
      // FIX 3 (15.1.1): Improved whistle ‚Äî cleaner ref whistle tone
      whistle(ctx){
        const t=ctx.currentTime;
        const o=ctx.createOscillator(),g=ctx.createGain();
        o.connect(g);g.connect(ctx.destination);
        o.type="sine";
        o.frequency.setValueAtTime(2600,t);
        o.frequency.setValueAtTime(2200,t+0.1);
        o.frequency.linearRampToValueAtTime(2000,t+0.25);
        g.gain.setValueAtTime(0.06,t);
        g.gain.linearRampToValueAtTime(0.09,t+0.03);
        g.gain.setValueAtTime(0.09,t+0.15);
        g.gain.exponentialRampToValueAtTime(0.001,t+0.28);
        o.start(t);o.stop(t+0.28);
      },
      // FIX 3 (15.1.1): Improved sack buzz ‚Äî harsh but less grating
      sackBuzz(ctx){
        const t=ctx.currentTime;
        // Growling low tone
        const o1=ctx.createOscillator(),g1=ctx.createGain();
        o1.connect(g1);g1.connect(ctx.destination);
        o1.type="sawtooth";o1.frequency.setValueAtTime(80,t);
        o1.frequency.exponentialRampToValueAtTime(35,t+0.25);
        g1.gain.setValueAtTime(0.12,t);
        g1.gain.exponentialRampToValueAtTime(0.001,t+0.3);
        o1.start(t);o1.stop(t+0.3);
        // Distorted mid for buzz character
        const o2=ctx.createOscillator(),g2=ctx.createGain(),ws=ctx.createWaveShaper();
        o2.connect(ws);ws.connect(g2);g2.connect(ctx.destination);
        o2.type="square";o2.frequency.setValueAtTime(120,t);
        o2.frequency.exponentialRampToValueAtTime(60,t+0.2);
        const curve=new Float32Array(256);
        for(let i=0;i<256;i++){const x=i*2/255-1;curve[i]=Math.tanh(x*2);}
        ws.curve=curve;
        g2.gain.setValueAtTime(0.06,t);
        g2.gain.exponentialRampToValueAtTime(0.001,t+0.25);
        o2.start(t);o2.stop(t+0.25);
      }
    };

    // ==================== MAIN COMPONENT ====================
    function TacticalFootball() {
      // FIX 3 (15.1): Sound mute state + helper
      const [sfxMuted, setSfxMuted] = useState(false);
      const sfxMuteRef = React.useRef(false);
      useEffect(()=>{sfxMuteRef.current=sfxMuted;},[sfxMuted]);
      const sfx=useCallback((fn)=>{if(!sfxMuteRef.current)try{fn(sfxCtx());}catch(e){}},[]);

      // FIX 2 (15.1.1): Global tick on every button/clickable press via event delegation
      useEffect(()=>{
        const handler=(e)=>{
          if(sfxMuteRef.current)return;
          const t=e.target;
          if(t.tagName==="BUTTON"||t.closest("button")||
             (t.tagName==="SPAN"&&t.style.cursor==="pointer")){
            try{SFX.tick(sfxCtx());}catch(e){}
          }
        };
        document.addEventListener("mousedown",handler,true);
        return ()=>document.removeEventListener("mousedown",handler,true);
      },[]);

      const [coachType, setCoachType] = useState(null);
      const [diff, setDiff] = useState(null);
      const [twoPlayer, setTwoPlayer] = useState(false);
      const [offensePlayer, setOffensePlayer] = useState(1);
      const [game, setGame] = useState({bo:25,dn:1,dst:10,sc:{p1:0,p2:0},q:1,pr:0,lastPlays:[]});
      const [mode, setMode] = useState("diff_select");
      const [pCat, setPCat] = useState(null);
      const [selPlay, setSelPlay] = useState(null);
      const [defSch, setDefSch] = useState(null);
      const [phase, setPhase] = useState(0);
      const [qbP, setQbP] = useState(R(50,-3));
      const [bc, setBc] = useState("qb");
      const [bcP, setBcP] = useState(null);
      const [isRun, setIsRun] = useState(false);
      const [isCatch, setIsCatch] = useState(false);
      const [result, setResult] = useState(null);
      const [log, setLog] = useState([]);
      const [handed, setHanded] = useState(false);
      const [ballP, setBallP] = useState(R(50,-3));
      const [ballFlightPos, setBallFlightPos] = useState(null); // {x,y} during ball flight arc
      const [ballSt, setBallSt] = useState("held");
      const [ballAn, setBallAn] = useState(false);
      const [camY, setCamY] = useState(0);
      const [runAct, setRunAct] = useState(0);
      const [narr, setNarr] = useState("");
      const [coach, setCoach] = useState("");
      const [defPos, setDefPos] = useState({});
      const [olPos, setOlPos] = useState({});
      const [showTD, setShowTD] = useState(false);
      const [matchups, setMatchups] = useState({});
      const [lookDir, setLookDir] = useState(null);
      const [routes, setRoutes] = useState({});
      const [showGhost, setShowGhost] = useState(false);
      const [contactData, setContactData] = useState(null);
      const [runArrows, setRunArrows] = useState([]);
      const [holeInfo, setHoleInfo] = useState(null);
      const [debrief, setDebrief] = useState("");
      const [pbp, setPbp] = useState([]);
      const [rpoData, setRpoData] = useState(null);
      const lastThrowOpenness = React.useRef(null);
      const lastThrowTarget = React.useRef(null);
      const tacklesBroken = React.useRef(0);
      const maxContactsRef = React.useRef(2); // Max contact decisions allowed this play
      const tuckWarnings = React.useRef(0);
      // FIX 4 (14.7): QB scramble lane ‚Äî computed once per phase
      const scrambleLaneRef = React.useRef({phase:-1,open:false});
      const [contactFlash, setContactFlash] = useState(null);
      const [commentary, setCommentary] = useState(null);
      const commentaryTimer = React.useRef(null);
      const [practiceOverlay, setPracticeOverlay] = useState(null);
      const [showMenuConfirm, setShowMenuConfirm] = useState(false);
      // FIX 7 (15.0): Broadcast-style pressure alerts
      const [fieldAlert, setFieldAlert] = useState(null);
      const fieldAlertTimer = React.useRef(null);
      const prevPiRef = React.useRef(100);
      const alertedOpen = React.useRef(false);
      const recSeeds = React.useRef({wr1:1,wr2:1,te:1,rb:1});
      const blitzUncovered = React.useRef(null);
      const practiceShown = React.useRef(new Set());

      // Ball flight arc ref (keeps arc data between rAF ticks)
      const ballFlightRef = React.useRef(null);   // {sx,sy,ex,ey,dur,start,peak} for arc
      // Cosmetic animation layer ‚Äî lerps toward React state, never writes game state
      const visualPos = React.useRef({});
      const playerElRefs = React.useRef({});
      const animFrameId = React.useRef(null);
      const lastAnimTime = React.useRef(0);
      const ySRef = React.useRef(null);
      const xSRef = React.useRef(null);
      const targetPosRef = React.useRef({});
      const bcRef = React.useRef("qb");

      // FIX 1 (15.1): Camera biased 70/30 upfield ‚Äî player sees where they're headed
      const camTarget = React.useRef(0);
      const camLerp = React.useRef(0.2);
      useEffect(() => {
        let t=0;
        let lerp=0.2;
        const viewYards=FH/PY;
        if(["diff_select","menu","playcall","fourth"].includes(mode)){
          t=0;
        } else if(mode==="presnap"){
          t=0;
        } else if(["snapping","animating"].includes(mode)&&!isRun){
          const recYs=["wr1","wr2","te","rb"].map(id=>offP[id]?.y||0).filter(y=>y>0);
          if(recYs.length>0){
            const deepest=Math.max(...recYs);
            t=Math.max(0,deepest-viewYards*0.55);
          }
        } else if(["decision","pressure"].includes(mode)){
          const recYs=["wr1","wr2","te","rb"].map(id=>offP[id]?.y||0).filter(y=>y>0);
          const qy=qbP?.y||0;
          const deepest=Math.max(...recYs,0);
          const shallowest=Math.min(qy,...recYs.filter(y=>y!==0));
          const span=deepest-shallowest;
          if(span>viewYards*0.8){
            t=Math.max(0,deepest-viewYards*0.55);
          } else {
            const midY=(deepest+shallowest)/2;
            t=Math.max(0,midY-viewYards*0.2);
          }
        } else if(isRun||isCatch){
          const c=bcP||(bc==="qb"?qbP:null);
          if(c){ t=Math.max(0,c.y-2); lerp=0.28; }
        } else if(mode==="result"||mode==="touchdown"){
          const c=bcP||(bc==="qb"?qbP:null);
          if(c) t=Math.max(0,c.y-2);
        }
        camTarget.current=t;
        camLerp.current=lerp;
      },[mode,bcP,qbP,bc,phase,runAct,isRun,isCatch,offP]);
      // Smooth lerp camera toward target
      useEffect(()=>{
        let raf;
        const step=()=>{
          setCamY(prev=>{
            const diff=camTarget.current-prev;
            if(Math.abs(diff)<0.05)return camTarget.current;
            raf=requestAnimationFrame(step);
            return prev+diff*camLerp.current;
          });
        };
        raf=requestAnimationFrame(step);
        return ()=>cancelAnimationFrame(raf);
      },[camTarget.current]);

      // Hard clamp ‚Äî ball carrier NEVER leaves screen (render-time safety net)
      const effectiveCamY = useMemo(() => {
        if ((isRun || isCatch || mode==="runner" || mode==="contact") && (bcP || (bc==="qb" && qbP))) {
          const c = bcP || qbP;
          const screenY = FH*0.7 - (c.y - camY) * PY;
          if (screenY < FH * 0.15) {
            return Math.max(0, c.y - (FH * 0.35) / PY);
          }
        }
        return camY;
      }, [camY, isRun, isCatch, mode, bcP, bc, qbP]);

      // 70% of screen shows upfield, 30% behind ‚Äî action framed in lower 30%
      const yS=useCallback(y=>FH*0.7-(y-effectiveCamY)*PY,[effectiveCamY]);
      const xS=p=>(p/100)*FW;


      const DEFAULT_OFF = useMemo(() => {
        const pos = { ...FI };
        for (const olId of OL_IDS) pos[olId] = R(pos[olId].x, pos[olId].y + 1);
        return pos;
      }, []);

      const getOffP=useCallback(ph=>{
        if(!selPlay) return DEFAULT_OFF;
        const pos={},f=selPlay.formation;
        for(const id of ["wr1","wr2","te","rb"]){
          const rt=routes[id];
          pos[id]=ph===0?f[id]:rt?rt[cl(ph-1,0,rt.length-1)]:f[id];
        }
        pos.qb=qbP;
        for(const olId of OL_IDS){if(olPos[olId])pos[olId]=olPos[olId];}
        return pos;
      },[selPlay,qbP,olPos,routes,DEFAULT_OFF]);

      const offP=getOffP(phase);
      const pi=getPocket(matchups);

      // FIX 7 (15.0): Detect pressure transitions and show broadcast alerts
      useEffect(() => {
        if (!["decision","pressure"].includes(mode)) { prevPiRef.current=100; alertedOpen.current=false; return; }
        const prev=prevPiRef.current;
        const showAlert=(text,color)=>{
          if(fieldAlertTimer.current)clearTimeout(fieldAlertTimer.current);
          setFieldAlert({text,color,key:Date.now()});
          fieldAlertTimer.current=setTimeout(()=>setFieldAlert(null),2000);
        };
        if(pi<30&&prev>=30) showAlert("POCKET COLLAPSING","#ef4444");
        else if(pi<50&&prev>=50) showAlert("PRESSURE BUILDING","#fbbf24");
        prevPiRef.current=pi;
        // Receiver open alert (once per play)
        if(!alertedOpen.current){
          const open=["wr1","wr2","te","rb"].find(id=>{const o=opn(id,offP,defPos,defSch);return o.o>=3;});
          if(open){ alertedOpen.current=true; showAlert(`${fmtTarget(open).toUpperCase()} WIDE OPEN`,"#22c55e"); }
        }
      },[pi,mode,phase]);

      useEffect(()=>{
        if(ballSt!=="held")return;
        let target = null;
        if(bc==="qb") target = qbP;
        else if(bcP) target = bcP;
        else target = offP[bc];
        
        if(target) {
          setBallP(prev => (prev.x === target.x && prev.y === target.y) ? prev : {...target});
        }
      },[ballSt,bc,qbP,bcP,offP,phase]);

      // ==================== COSMETIC ANIMATION LAYER ====================
      // Lerps visualPos toward React state. NEVER writes game state.
      useEffect(() => { ySRef.current = yS; }, [yS]);
      useEffect(() => { xSRef.current = xS; }, [xS]);
      useEffect(() => { bcRef.current = bc; }, [bc]);

      // Sync React state positions into targetPosRef for the animation loop
      useEffect(() => {
        const t = {};
        for (const [id, pos] of Object.entries(offP)) if (pos) t[`off-${id}`] = pos;
        let dPos = defPos || {};
        if (Object.keys(olPos).length > 0) {
          const clamped = { ...dPos };
          for (const [dl, olId] of Object.entries(OL_BLK)) {
            if (clamped[dl] && olPos[olId] && clamped[dl].y < olPos[olId].y) clamped[dl] = R(clamped[dl].x, olPos[olId].y);
          }
          dPos = clamped;
        }
        for (const [id, pos] of Object.entries(dPos)) if (pos) t[`def-${id}`] = pos;
        targetPosRef.current = t;
      }, [offP, defPos, olPos]);

      const animationLoop = useCallback((now) => {
        if (!lastAnimTime.current) lastAnimTime.current = now;
        const dt = Math.min((now - lastAnimTime.current) / 1000, 0.05);
        lastAnimTime.current = now;
        const ysFn = ySRef.current, xsFn = xSRef.current;
        if (!ysFn || !xsFn) { animFrameId.current = requestAnimationFrame(animationLoop); return; }

        // Lerp players toward React-state targets
        for (const [key, tgt] of Object.entries(targetPosRef.current)) {
          if (!tgt) continue;
          if (!visualPos.current[key]) visualPos.current[key] = { ...tgt };
          const vp = visualPos.current[key];
          let speed = LERP_REC;
          if (key === "off-qb") speed = LERP_QB;
          else if (key.startsWith("off-ol") || key === "off-c") speed = LERP_OL;
          else if (key.startsWith("def-de") || key.startsWith("def-dt")) speed = LERP_DL;
          else if (key.startsWith("def-")) speed = LERP_DEF;
          vp.x = lerpVal(vp.x, tgt.x, speed, dt);
          vp.y = lerpVal(vp.y, tgt.y, speed, dt);
          // DL clamping
          if (key.startsWith("def-")) {
            const olId = OL_BLK[key.replace("def-","")];
            if (olId) { const olV = visualPos.current[`off-${olId}`]; if (olV && vp.y < olV.y) vp.y = olV.y; }
          }
          // Skip DOM update for ball carrier ‚Äî React owns BC rendering
          const curBc = bcRef.current;
          if (curBc !== "qb" && key === `off-${curBc}`) continue;
          const el = playerElRefs.current[key];
          if (el) {
            el.style.left = (xsFn(vp.x) - (el.offsetWidth || 28) / 2) + "px";
            el.style.top = (ysFn(vp.y) - (el.offsetHeight || 28) / 2) + "px";
          }
        }

        // Ball flight arc ‚Äî cosmetic parabola, updates React state for renderBall
        const bf = ballFlightRef.current;
        if (bf) {
          const t = Math.min((now - bf.start) / bf.dur, 1);
          const bx = bf.sx + (bf.ex - bf.sx) * t;
          const by = bf.sy + (bf.ey - bf.sy) * t + bf.peak * 4 * t * (1 - t);
          setBallFlightPos({x: bx, y: by});
        }

        animFrameId.current = requestAnimationFrame(animationLoop);
      }, []);

      const startAnim = useCallback(() => {
        if (animFrameId.current) return;
        lastAnimTime.current = 0;
        animFrameId.current = requestAnimationFrame(animationLoop);
      }, [animationLoop]);
      const stopAnim = useCallback(() => {
        if (animFrameId.current) { cancelAnimationFrame(animFrameId.current); animFrameId.current = null; }
        lastAnimTime.current = 0;
      }, []);
      useEffect(() => {
        const active = ["snapping","animating","decision","pressure","runner","contact","rpo"];
        if (active.includes(mode)) startAnim(); else stopAnim();
        return () => stopAnim();
      }, [mode, startAnim, stopAnim]);

      const recomputePass=useCallback((ph,qP,mu,ld)=>{
        if(!defSch||!selPlay)return;
        const ol=computePassOL(mu); setOlPos(ol);
        const oP={};
        for(const id of ["wr1","wr2","te","rb"]){
          const rt=routes[id];
          oP[id]=ph===0?selPlay.formation[id]:rt?rt[cl(ph-1,0,rt.length-1)]:selPlay.formation[id];
        }
        oP.qb=qP; Object.assign(oP,ol);
        setDefPos(computeDefPass(defSch,ph,qP,oP,ol,mu,ld,diff,recSeeds.current,blitzUncovered.current));
      },[defSch,selPlay,routes,diff]);

      useEffect(()=>{
        if(phase>0&&defSch&&selPlay&&!isRun) recomputePass(phase,qbP,matchups,lookDir);
      },[phase,defSch,selPlay,isRun,qbP,matchups,lookDir,recomputePass]);

      // Practice Mode overlay triggers
      useEffect(()=>{
        if(diff!=="practice")return;
        const ps=practiceShown.current;
        if(mode==="menu"&&!ps.has("menu")){
          setPracticeOverlay("This is your playbook. Each play is a different plan for how to move the ball. Run plays hand the ball to your running back. Pass plays have the quarterback throw to a receiver. Tap any play to see what it does.");
          ps.add("menu");
        } else if(mode==="menu"&&ps.has("menu")&&!ps.has("menu2")){
          setPracticeOverlay("Pick your next play. Remember, green tags mean this play is strong against their defense.");
          ps.add("menu2");
        } else if(mode==="presnap"&&defSch){
          const defExplain=defSch.key==="blitz"?"Blitz means they're sending extra rushers at your quarterback ‚Äî you'll have less time to throw, but fewer defenders covering receivers.":defSch.key==="cover2"?"Cover 2 puts two safeties deep ‚Äî hard to throw deep, but short routes are open.":defSch.key==="nickel"?"Nickel adds an extra defensive back ‚Äî better pass coverage, but weaker against the run.":defSch.key==="goalline"?"Goal Line packs everyone at the line ‚Äî great at stopping short runs, but zero deep coverage.":"Base 4-3 is a balanced defense ‚Äî they're ready for both run and pass.";
          const mxR=selPlay?MX[selPlay.name]?.[defSch.key]||0:0;
          let txt=`The defense just lined up in ${defSch.name}. ${defExplain}`;
          if(mxR<=-1)txt+=` Your play isn't great against this defense. See those red tags? You can tap AUDIBLE to switch, or go ahead and try it ‚Äî it's practice!`;
          else if(mxR>=1)txt+=` Great pick! Your play is strong against this defense. The green tag means you have an advantage.`;
          setPracticeOverlay(txt);
        } else if(mode==="decision"&&!ps.has("decision")){
          setPracticeOverlay("Your quarterback has the ball. Now you decide what to do with it. Drop Back moves him away from the defense and gives your receivers time to get open. Try it!");
          ps.add("decision");
        } else if(mode==="decision"&&phase>=2&&!ps.has("decision2")){
          setPracticeOverlay("Good! See how the receivers moved further down the field? The labels on the field show you who's open (green) and who's covered (red). When you see a receiver marked OPEN, tap their name to throw to them.");
          ps.add("decision2");
        } else if(mode==="rpo"&&!ps.has("rpo")){
          setPracticeOverlay("The line just moved. See that message? This tells you what happened at the line of scrimmage. If there's a hole, hand it off! If the defense read it, you might want the QB to keep it or throw a quick pass instead.");
          ps.add("rpo");
        } else if(mode==="contact"&&!ps.has("contact")){
          setPracticeOverlay("Your runner hit traffic! These buttons are his options. Look at the percentages ‚Äî higher means more likely to work. Dive Forward is always safe but short. Sprint is great if the field ahead is clear. Juke is risky but might break a big play.");
          ps.add("contact");
        } else if(mode==="runner"&&!ps.has("runner")){
          setPracticeOverlay("Time to run! Each button shows a direction and success percentage. Sprint goes straight ahead for safe yards. Cut Outside tries the sideline ‚Äî risky but bigger gain. Juke is a long shot but could break huge. Dive Forward is always safe. The percentages change based on where defenders are ‚Äî read the field!");
          ps.add("runner");
        }
      },[mode,diff,phase,defSch,selPlay]);

      const selectPlay=p=>{setSelPlay(p);setRoutes(getRoutes(p));setShowGhost(true);};
      const quickSnap=p=>{setSelPlay(p);setRoutes(getRoutes(p));setShowGhost(true);setTimeout(()=>goPresnapFor(p),0);};
      // Shared presnap setup: accepts a play and defense object
      const setupPresnap=(p,def)=>{
        setDefSch(def);
        const sq=p.formation.qb; setQbP(sq);
        const mu=initMatchups(def); setMatchups(mu);
        const ol=computePassOL(mu); setOlPos(ol);
        const oP={...p.formation,qb:sq,...ol};
        recSeeds.current={wr1:1,wr2:1,te:1,rb:1};
        blitzUncovered.current=def.key==="blitz"?(Math.random()<0.5?"wr2":"te"):null;
        const dPos=computeDefPass(def,0,sq,oP,ol,mu,null,diff,recSeeds.current,blitzUncovered.current);
        setDefPos(dPos);
        setLookDir(null);
        // Teleport visual positions to formation (no lerp on presnap)
        for (const [id, pos] of Object.entries(p.formation)) visualPos.current[`off-${id}`] = { ...pos };
        for (const olId of OL_IDS) { if(ol[olId]) visualPos.current[`off-${olId}`] = { ...ol[olId] }; }
        for (const [id, pos] of Object.entries(dPos)) visualPos.current[`def-${id}`] = { ...pos };
        ballFlightRef.current = null;
        const mxR = MX[p.name]?.[def.key] || 0;
        setCoach(coachPresnap(def, p, mxR, game, coachType));
        setMode("presnap");
      };
      const goPresnapFor=(p)=>{
        if(twoPlayer){ setMode("p2_defense"); return; }
        setupPresnap(p, pickDef(game.dn,game.dst,game.bo,diff));
      };
      // P2 picks defense in two-player mode
      const p2PickDef=(defKey)=>{
        const def={key:defKey,...DEFS[defKey]};
        setupPresnap(selPlay, def);
      };

      const goPresnap=()=>{
        if(twoPlayer){ setMode("p2_defense"); return; }
        setupPresnap(selPlay, pickDef(game.dn,game.dst,game.bo,diff));
      };

      const snap=()=>{
        sfx(SFX.snap);
        setPhase(0);setBc("qb");setBcP(null);setIsRun(false);setIsCatch(false);
        setResult(null);setHanded(false);setBallSt("held");setBallAn(false);
        setRunAct(0);setNarr("");setCamY(0);setShowTD(false);setShowGhost(isPre(diff));if(commentaryTimer.current)clearTimeout(commentaryTimer.current);setCommentary(null);setPracticeOverlay(null);
        lastThrowOpenness.current=null;lastThrowTarget.current=null;tacklesBroken.current=0;tuckWarnings.current=0;maxContactsRef.current=2;scrambleLaneRef.current={phase:-1,open:false};setContactFlash(null);if(fieldAlertTimer.current)clearTimeout(fieldAlertTimer.current);setFieldAlert(null);
        recSeeds.current={wr1:1,wr2:1,te:1,rb:1};blitzUncovered.current=defSch?.key==="blitz"?(Math.random()<0.5?"wr2":"te"):null;
        setRunArrows([]);setHoleInfo(null);setDebrief("");setPbp(["Snap"]);setRpoData(null);
        const sq=selPlay.formation.qb; setQbP(sq);setBallP({...sq});
        const mu=initMatchups(defSch); setMatchups(mu); setLookDir(null);
        // Teleport visual positions to formation (no lerp on snap)
        for (const [id, pos] of Object.entries(selPlay.formation)) visualPos.current[`off-${id}`] = { ...pos };
        visualPos.current["bc-overlay"] = null;
        ballFlightRef.current = null;

        // Ball snap flight: center to QB via arc
        setBallP({...selPlay.formation.c});setBallSt("air");setBallAn(true);
        const snapDist = dst(selPlay.formation.c, sq);
        const snapFlightMs = cl(snapDist * 30 + 100, 120, 300);
        ballFlightRef.current = {
          sx: selPlay.formation.c.x, sy: selPlay.formation.c.y,
          ex: sq.x, ey: sq.y,
          dur: snapFlightMs, start: performance.now(), peak: Math.min(1.5, snapDist * 0.1)
        };
        setBallP({...sq}); // target for state consistency
        setTimeout(()=>{
          ballFlightRef.current = null;
          setTimeout(()=>{
            setBallSt("held");setBallAn(false);setPhase(1);
            if(selPlay.qbSneak){
              const sneakGain = rnd(1,3) - (defSch.key === "goalline" ? 1 : 0);
              const nP = R(sq.x, sq.y + sneakGain);
              setIsRun(true);setBc("qb");setBcP(nP);setBallP({...nP});
              setNarr(`QB pushes forward for ${sneakGain}!`);
              setMode("animating");
              setTimeout(()=>endPlay(sneakGain, `QB Sneak ‚Äî pushes for +${sneakGain}`),ANIM);
            } else if(selPlay.type==="run"&&!selPlay.qbDraw){
              setTimeout(()=>{
                const mxR=MX[selPlay.name]?.[defSch.key]||0;
                const isOut=selPlay.name==="Outside Run"||selPlay.name==="HB Toss"||selPlay.name==="Stretch Run";
                // Fix ordering: check -2 before -1. Add defense-type bonus: pass defenses favor runs.
                const baseOpen=mxR>=2?85:mxR>=1?70:mxR<=-2?10:mxR<=-1?20:50;
                const defRunBonus=defSch.key==="cover2"?15:defSch.key==="nickel"?12:defSch.key==="goalline"?-15:defSch.key==="base43"?-8:0;
                const openPct=cl(baseOpen+defRunBonus,5,95);
                console.log(`[RPO] play=${selPlay.name} vs ${defSch.key} mxR=${mxR} base=${baseOpen} defBonus=${defRunBonus} final=${openPct}`);
                const scenario=Math.random()*100<openPct?"gap_open":isOut?"edge_sealed":"lb_filled";
                const msgs=isPre(diff)?{
                  gap_open:"üëÄ There's a hole! The blockers made room to run. Hand it off!",
                  lb_filled:"‚ö†Ô∏è A defender read the play and closed the running lane. Handoff is risky ‚Äî consider keeping it or throwing quick.",
                  edge_sealed:"‚ö†Ô∏è The defense shut down the outside ‚Äî no room to run wide. Adjust your plan."
                }:{
                  gap_open:coachType==="A"?"üëÄ Gap is wide open! Feed the RB and let him eat.":"üëÄ Good news ‚Äî the hole has daylight. Handoff looks great here.",
                  lb_filled:coachType==="A"?"‚ö†Ô∏è Linebacker shot the gap! Don't hand it off into that mess.":"‚ö†Ô∏è LB filled the hole ‚Äî handoff is risky. Consider keeping it or throwing quick.",
                  edge_sealed:coachType==="A"?"‚ö†Ô∏è Edge is locked down! The DE has contain.":"‚ö†Ô∏è Edge is sealed ‚Äî outside run won't work. Adjust your plan."
                };
                setRpoData({scenario,mxR,isOut});setCoach(msgs[scenario]);setMode("rpo");
              },ANIM);
            } else if(selPlay.flea){
              setHanded(true);setIsRun(true);setBc("rb");
              const rbPos=routes.rb?routes.rb[0]:selPlay.formation.rb;
              setBcP(rbPos);setBallP({...rbPos});setBallSt("held");
              setNarr("Handoff to RB... running forward...");
              setCoach("ü™∞ RB has it ‚Äî wait for the pitch back!");
              setMode("animating");
              setTimeout(()=>{
                const fleaMult=diff==="practice"?0.05:diff==="preseason"?0.3:diff==="regular"?0.6:1.0;
                if(Math.random()<selPlay.fleaFumble*fleaMult){
                  setBallSt("loose");
                  endPlay(0,"FUMBLE on the pitch back! Flea flicker disaster!",true);
                } else {
                  setIsRun(false);setBc("qb");setBcP(null);setHanded(false);
                  setBallSt("held"); setBallP({...sq});
                  setPhase(2);setNarr("RB pitches back to QB! Defense bought the fake!");
                  setCoach("üéØ Defense bit hard on the run ‚Äî let it fly!");
                  setTimeout(()=>setMode("decision"),ANIM);
                }
              },ANIM*2);
            } else if(selPlay.statue){
              setNarr("QB drops back like a normal pass...");
              setCoach("üóΩ Sell the fake. Use 'Statue' to slip it to the RB when you're ready.");
              setTimeout(()=>setMode("decision"),ANIM);
            } else if(selPlay.qbDraw){
              setNarr("QB drops back in passing stance...");
              setCoach("üé≠ Defense sees pass ‚Äî hit 'Tuck & Run' through the gaps they left.");
              setTimeout(()=>setMode("decision"),ANIM);
            } else {
              setTimeout(()=>{
                const blitzPct=diff==="practice"?0.02:diff==="preseason"?0.05:diff==="regular"?0.12:0.20;
                if(defSch.key==="blitz"&&Math.random()<blitzPct){
                  setNarr("The blitz got through clean!");
                  setCoach(isPre(diff)?"The blitz got through clean ‚Äî nothing you could do there. Make a quick decision!":"Immediate pressure! Decide NOW!");
                  setMode("pressure");
                } else {
                  setMode("decision");
                  setCoach(coachQB(1,offP,defPos,mu,defSch,null,coachType,diff));
                }
              },ANIM);
            }
          },250);
        },snapFlightMs);
        setMode("snapping");
      };

      const endPlay=(yds,desc,turnover=false,incomplete=false,reason="")=>{
        // FIX 1 (15.1.2): UNIVERSAL PHANTOM TACKLE GATE
        // If this is a tackle play (not TD/incomplete/turnover), verify a defender is actually close.
        // Uses game-state defPos for defender proximity check.
        const isTacklePlay=!turnover&&!incomplete&&(game.bo+yds)<100;
        if(isTacklePlay){
          const carrierPos=bcP||(bc==="qb"?qbP:null);
          if(carrierPos){
            const nd=nearD(carrierPos,defPos);
            if(nd.d>=3){
              // No defender within 3 yards ‚Äî phantom tackle! Abort endPlay, return to runner mode.
              const bonus=rnd(3,6);
              const fP=R(carrierPos.x+rnd(-3,3), Math.min(carrierPos.y+bonus, 99-game.bo));
              setBcP(fP);setBallP({...fP});
              const ndp2=pursue(defPos,fP,runAct+1,bc);
              setDefPos(ndp2);
              const arrows2=computeRunArrows(fP,ndp2,game,runAct,bc,holeInfo,diff);setRunArrows(arrows2);
              setNarr("Breaks free! Still running!");
              setCoach("");
              animThen(()=>setMode("runner"),ANIM);
              return; // Abort endPlay ‚Äî play continues in runner mode
            }
          }
        }
        if(incomplete)setBallSt("ground");if(turnover)setBallSt("loose");
        const nb=game.bo+yds;
        const res={yds,desc,turnover,incomplete,td:false,reason};
        if(nb>=100&&!turnover&&!incomplete){
          res.td=true;setShowTD(true);setMode("touchdown");
        } else setMode("result");
        setPbp(p=>[...p,res.td?"TOUCHDOWN!":desc]);
        setResult(res);setNarr("");setRunArrows([]);
        setCoach("");  // Clear stale decision-time advice ‚Äî debrief handles result commentary
        // FIX 2 (14.9.1): Delay announcer booth by 1.5s so field result is visible first
        const comm=generateCommentary(res,selPlay,defSch,game,diff,lastThrowOpenness.current,lastThrowTarget.current);
        setCommentary(null);
        if(commentaryTimer.current)clearTimeout(commentaryTimer.current);
        commentaryTimer.current=setTimeout(()=>setCommentary(comm),2750);
        setDebrief(postPlayDebrief(res,selPlay,defSch,matchups,diff));
        // FIX 3 (15.1): Sound effects
        if(res.td){ sfx(SFX.crowd); }
        else if(res.turnover||yds<0){ sfx(SFX.sackBuzz); }
        else if(yds>=15){ sfx(SFX.crowd); setTimeout(()=>sfx(SFX.whistle),300); }
        else if(!res.incomplete){ sfx(SFX.tackle); setTimeout(()=>sfx(SFX.whistle),200); }
        else { sfx(SFX.whistle); }
      };

      const animThen=(fn,minDelay)=>{
        setMode("animating");
        setTimeout(fn, minDelay || 400);
      };

      const doRPO=ch=>{
        const sLbl=isPre(diff)?(rpoData?.scenario==="gap_open"?"Hole Open":rpoData?.scenario==="lb_filled"?"Lane Closed":"Outside Shut Down"):(rpoData?.scenario==="gap_open"?"Gap Open":rpoData?.scenario==="lb_filled"?"LB Filled Gap":"Edge Sealed");
        const rpoLbl={handoff:"Hand Off",handoff_bad:"Hand Off Anyway",qb_keep:"QB Keep",quick_pass:"Quick Pass"};
        setPbp(p=>[...p,`Read: ${sLbl} ‚Üí ${rpoLbl[ch]||ch}`]);
        if(ch==="handoff"||ch==="handoff_bad"){
          const mxR = MX[selPlay.name]?.[defSch.key] || 0;
          const {olPos:rOL,defAdj,holeInfo:hi}=computeRunOL(selPlay.name,defSch.pos,defSch,mxR);
          setIsRun(true);setBc("rb");setHanded(true);
          const rbR=routes.rb;
          const rbPos=rbR?rbR[0]:selPlay.formation.rb;
          const tossMult=diff==="practice"?0.05:diff==="preseason"?0.3:diff==="regular"?0.6:1.0;
          if(selPlay.tossFumble&&Math.random()<selPlay.tossFumble*tossMult){
            setBcP(rbPos);setBallP({...rbPos});setBallSt("loose");
            setNarr("FUMBLE on the pitch!");
            animThen(()=>endPlay(0,"FUMBLE! Ball on the ground!",true),ANIM);return;
          }
          setBcP(rbPos);setBallP({...rbPos});setBallSt("held");
          const newDef = { ...defSch.pos };
          for (const [did, adj] of Object.entries(defAdj)) { newDef[did] = adj; }
          for (const p of DEF) { if (p.pos === "LB" && !defAdj[p.id]) { const s = defSch.pos[p.id]; newDef[p.id] = R(s.x + (rbPos.x - s.x) * 0.12, s.y + (rbPos.y - s.y) * 0.08); } }
          for (const p of DEF) { if ((p.pos === "CB" || p.pos === "S") && !defAdj[p.id]) { newDef[p.id] = defSch.pos[p.id]; } }
          setDefPos(newDef);setOlPos(rOL);setHoleInfo(hi);
          if(ch==="handoff_bad"){
            setNarr("Handoff into traffic!");setCoach("Brace for contact!");
            const dp=pursue(newDef,rbPos,1,"rb");const dp2=pursue(dp,rbPos,2,"rb");setDefPos(dp2);
            animThen(()=>{setPhase(p=>p+1);triggerContact(rbPos,dp2);},ANIM);
          } else {
            const arrows = computeRunArrows(rbPos, newDef, game, 0, "rb", hi, diff);setRunArrows(arrows);
            setNarr("Handoff to RB!");setCoach(coachRunner(rbPos, newDef, arrows, game, coachType));
            animThen(()=>{setPhase(p=>p+1);setMode("runner");},ANIM);
          }
        } else if(ch==="qb_keep"){
          setIsRun(true);setBc("qb");setBcP({...qbP});setIsCatch(false);setRunAct(0);
          setNarr("QB fakes the handoff and keeps it!");setCoach("üèÉ QB on the move ‚Äî find daylight!");
          const dp=pursue(defPos,qbP,1,"qb");setDefPos(dp);
          const arrows=computeRunArrows(qbP,dp,game,0,"qb",null,diff);setRunArrows(arrows);
          animThen(()=>{setPhase(p=>p+1);setMode("runner");},ANIM);
        } else if(ch==="quick_pass"){
          // BUG 4 FIX: Quick pass scales with defensive commitment
          const sc=rpoData?.scenario;
          const wrId=offP.wr1&&offP.wr2?(Math.abs(offP.wr1.x-50)<Math.abs(offP.wr2.x-50)?"wr1":"wr2"):"wr1";
          const wrPos=offP[wrId]||selPlay.formation[wrId]||R(20,2);
          // Edge sealed = defense sold out for run, receivers wide open
          // LB filled = partial commit, contested throw
          // Gap open = defense played honest, safe bubble only
          const comp=sc==="edge_sealed"?rnd(85,92):sc==="lb_filled"?rnd(60,72):rnd(80,90);
          const intChance=sc==="edge_sealed"?0.5:sc==="lb_filled"?4:3;
          const ydsLo=sc==="edge_sealed"?8:sc==="lb_filled"?5:3;
          const ydsHi=sc==="edge_sealed"?15:sc==="lb_filled"?8:5;
          const roll=Math.random()*100;
          setBallSt("air");setBallAn(true);
          const qpThrowDist = dst(qbP, wrPos);
          const qpFlightMs = cl(qpThrowDist * 35 + 150, 250, 700);
          const qpArcPeak = Math.min(BALL_ARC_MAX * 0.6, qpThrowDist * 0.15);
          ballFlightRef.current = {
            sx: qbP.x, sy: qbP.y,
            ex: wrPos.x, ey: wrPos.y,
            dur: qpFlightMs, start: performance.now(), peak: qpArcPeak
          };
          setBallP({...wrPos}); // target for state consistency
          setTimeout(()=>{
            ballFlightRef.current = null;
            setBallAn(false);
            if(roll<intChance){setPbp(p=>[...p,"INTERCEPTED"]);setBallSt("loose");endPlay(0,`Quick pass INTERCEPTED!`,true,false,sc==="edge_sealed"?"Defender read the RPO and jumped the route.":"Defender jumped the bubble route.");}
            else if(roll>comp){setPbp(p=>[...p,"Incomplete"]);setBallSt("ground");endPlay(0,"Quick pass incomplete",false,true,sc==="edge_sealed"?"Rushed the throw ‚Äî receiver was open.":"Bubble pass off target.");}
            else{const g=rnd(ydsLo,ydsHi);setPbp(p=>[...p,`${wrId.toUpperCase()} catches for +${g}`]);endPlay(g,sc==="edge_sealed"?`RPO pass to wide-open ${wrId.toUpperCase()} for +${g}!`:sc==="lb_filled"?`Contested RPO pass to ${wrId.toUpperCase()} for +${g}`:`Bubble pass to ${wrId.toUpperCase()} for +${g}`);}
          },qpFlightMs);
        }
      };

      const doQB=action=>{
        const np=phase+1;setNarr("");
        const pbpLabels={dropback:"Drop Back",scramble_left:"Roll Left",scramble_right:"Roll Right",step_up:"Step Up",look_left:"Look Left",look_right:"Look Right",handoff:"Handoff to RB",statue_handoff:"Statue of Liberty",tuck_run:"Tuck & Run",throw_away:"Throw Away",tuck_ball:"Tuck the Ball",scramble_lane:"QB Scramble"};
        if(action.type==="throw")setPbp(p=>[...p,`Pass to ${action.target.toUpperCase()}`]);
        else if(pbpLabels[action.type])setPbp(p=>[...p,pbpLabels[action.type]]);
        let mu=matchups;
        if(!action.type.startsWith("look")){mu=degradeMatchups(matchups,defSch);setMatchups(mu);}
        // CHANGE 7: Look mechanic costs pocket in Regular/Playoffs (5-10% degradation)
        else if(!isPre(diff)){mu=degradeMatchups(matchups,defSch,0.35);setMatchups(mu);}
        const newPI=getPocket(mu);

        // FIX 3: Track tuck warnings in Practice/Preseason ‚Äî auto-sack after repeated ignoring
        if (["dropback","scramble_left","scramble_right","step_up"].includes(action.type) && newPI < 40 && isPre(diff)) {
          tuckWarnings.current++;
          const warnLimit = diff === "practice" ? 3 : 2;
          if (tuckWarnings.current > warnLimit) {
            const l = rnd(1,3);
            setPbp(p=>[...p,"SACKED (held too long)"]);
            setCoach(diff === "practice"
              ? "That's what happens when you hold it too long. When I say tuck it, tuck it ‚Äî you'll lose a yard or two but you keep the ball."
              : "He held it too long ‚Äî the rush got home. When the pocket breaks down, protect the ball.");
            endPlay(-l, `SACKED! Held the ball too long ‚Äî loss of ${l}`, false, false,
              "The coach warned you to tuck the ball. Ignoring the warning let the defense get there.");
            return;
          }
        }

        // FIX 8: Receivers peak at Phase 3-4, then coverage tightens back up
        // Before phase 4: seeds grow (receivers get open)
        // After phase 4: seeds shrink (coverage adjusts, window closes)
        for(const rid of ["wr1","wr2","te","rb"]){
          if(np<=4){
            recSeeds.current[rid]=Math.min(2.0, recSeeds.current[rid] + 0.08 + Math.random()*0.07);
          } else {
            // Coverage recovery ‚Äî defenders adjust and close back down
            recSeeds.current[rid]=Math.max(0.7, recSeeds.current[rid] - 0.10 - Math.random()*0.08);
          }
        }

        switch(action.type){
          case "dropback":{const nq=R(qbP.x,qbP.y-2.5);setQbP(nq);setPhase(np);setCoach(coachQB(np,offP,defPos,mu,defSch,lookDir,coachType,diff));animThen(()=>{{const sr=checkSack(np,mu,nq);if(sr==="pressure")setMode("pressure");else if(sr==="safe")setMode("decision");};},ANIM);break;}
          case "scramble_left":{const nq=R(cl(qbP.x-14,5,95),qbP.y-1);setQbP(nq);setPhase(np);setCoach("Rolling left ‚Äî look for a target.");animThen(()=>{{const sr=checkSack(np,mu,nq);if(sr==="pressure")setMode("pressure");else if(sr==="safe")setMode("decision");};},ANIM);break;}
          case "scramble_right":{const nq=R(cl(qbP.x+14,5,95),qbP.y+1);setQbP(nq);setPhase(np);setCoach("Rolling right ‚Äî check the field.");animThen(()=>{{const sr=checkSack(np,mu,nq);if(sr==="pressure")setMode("pressure");else if(sr==="safe")setMode("decision");};},ANIM);break;}
          case "step_up":{const nq=R(qbP.x,qbP.y+rnd(2,4));setQbP(nq);setPhase(np);setNarr("QB steps up through the gap!");setCoach("Stepped up ‚Äî make your read.");animThen(()=>{{const sr=checkSack(np,mu,nq);if(sr==="pressure")setMode("pressure");else if(sr==="safe")setMode("decision");};},ANIM);break;}
          case "look_left":{setLookDir("left");setPhase(np);setNarr(isPre(diff)?"QB looks left ‚Äî safety moves that way. Receivers on the RIGHT are more open now!":"QB eyes left ‚Äî safeties bite");setCoach(isPre(diff)?"Looking one way fools the safety into moving left ‚Äî now throw right where there's less coverage.":coachQB(np,offP,defPos,mu,defSch,"left",coachType,diff));animThen(()=>setMode("decision"),ANIM);break;}
          case "look_right":{setLookDir("right");setPhase(np);setNarr(isPre(diff)?"QB looks right ‚Äî safety shifts over. Receivers on the LEFT are more open now!":"QB eyes right ‚Äî safeties shift");setCoach(isPre(diff)?"Looking right draws the safety that way ‚Äî now throw left where there's less coverage.":coachQB(np,offP,defPos,mu,defSch,"right",coachType,diff));animThen(()=>setMode("decision"),ANIM);break;}
          case "throw":{
            const curOff=getOffP(phase);
            const res=doThrow(action.target,phase,curOff,defPos,defSch,newPI,lookDir,{cp:action.cp,ip:action.ip,op:action.op},diff);
            lastThrowOpenness.current=action.op?.lab||null;
            lastThrowTarget.current=action.target;
            const tp=curOff[action.target];
            const flightTarget = {x:tp.x, y:tp.y};
            setBallSt("air");setBallAn(true);
            const throwDist = dst(qbP, flightTarget);
            const flightMs = cl(throwDist * 40 + 200, 300, 900);
            const arcPeak = Math.min(BALL_ARC_MAX, throwDist * 0.25);
            ballFlightRef.current = {
              sx: qbP.x, sy: qbP.y,
              ex: flightTarget.x, ey: flightTarget.y,
              dur: flightMs, start: performance.now(), peak: arcPeak
            };
            setBallP({...flightTarget}); // state target during flight
            setTimeout(()=>{
              ballFlightRef.current = null;
              setBallAn(false);
              if(res.int){setPbp(p=>[...p,"INTERCEPTED"]);setBallSt("loose");endPlay(0,res.msg,true,false,res.reason);}
              else if(!res.ok){setPbp(p=>[...p,"Incomplete"]);setBallSt("ground");endPlay(0,res.msg,false,true,res.reason);}
              else{
                setPbp(p=>[...p,`Caught at +${res.yds}`]);
                const catchP={x:flightTarget.x,y:flightTarget.y};
                // Snap cosmetic refs BEFORE setState so rAF skips this player immediately
                bcRef.current=res.cId;
                visualPos.current[`off-${res.cId}`]={...catchP};
                setBallSt("held");setBc(res.cId);setBcP({...catchP});setBallP({...catchP});
                setIsRun(true);setIsCatch(true);setRunAct(0);
                // BUG 2 FIX: Single pursue only, enforce min 2yd separation so catch isn't instant tackle
                let dp=pursue(defPos,catchP,1,res.cId);
                // Ensure no defender lands directly on the catch point
                for(const [did,dpos] of Object.entries(dp)){
                  const d=dst(catchP,dpos);
                  if(d<2.5){
                    const dx=(dpos.x-catchP.x)*0.533,dy=dpos.y-catchP.y;
                    const dist=Math.sqrt(dx*dx+dy*dy)||1;
                    dp[did]=R(catchP.x+(dx/dist)*2.5/0.533, catchP.y+(dy/dist)*2.5);
                  }
                }
                setDefPos(dp);
                // Three-tier YAC ‚Äî use game-state defender positions
                const catchNd=nearD(catchP,dp);
                const effectiveDist=catchNd.d;
                if(effectiveDist<2){
                  // TIER 1: Defender genuinely within 2 yards ‚Äî immediate tackle
                  const tackleGain=rnd(0,1);
                  const tackleP=R(catchP.x,catchP.y+tackleGain);
                  setBcP(tackleP);setBallP({...tackleP});
                  setPbp(p=>[...p,"Tackled immediately"]);
                  setNarr(`${res.cId.toUpperCase()} catches for ${fmtYds(res.yds)} but the defender was right there ‚Äî tackled on contact.`);
                  const tackler=catchNd.p?(catchNd.p.pos==="CB"?"cornerback":catchNd.p.pos==="S"?"safety":catchNd.p.pos==="LB"?"linebacker":"defender"):"defender";
                  animThen(()=>endPlay(Math.round(tackleP.y),`${res.cId.toUpperCase()} catches for ${fmtYds(Math.round(tackleP.y))} but gets tackled immediately by the ${tackler}`),ANIM);
                } else if(effectiveDist<4){
                  // TIER 2: Defender 2-4 yards ‚Äî one move, then tackled (~30% of catches)
                  maxContactsRef.current=1;
                  setRunAct(0);
                  setNarr(`${res.cId.toUpperCase()} catches for ${fmtYds(res.yds)} ‚Äî defender closing fast, one chance to make a move!`);
                  const ndp=pursue(dp,catchP,1,res.cId);setDefPos(ndp);
                  const arrows=computeRunArrows(catchP,ndp,game,0,res.cId,null,diff);setRunArrows(arrows);
                  setCoach(coachRunner(catchP,ndp,arrows,game,coachType));
                  animThen(()=>setMode("runner"),ANIM);
                } else {
                  // TIER 3: Defender 4+ yards ‚Äî open field, auto-gain (+3-8 bonus)
                  const bonus=rnd(3,8);
                  const nP=R(catchP.x+rnd(-4,4),catchP.y+bonus);
                  setBcP(nP);setBallP({...nP});
                  setPbp(p=>[...p,`Open field +${bonus}`]);
                  setNarr(`${res.cId.toUpperCase()} catches for ${fmtYds(res.yds)} in space ‚Äî picks up ${bonus} more!`);
                  animThen(()=>{
                    if(game.bo+Math.round(nP.y)>=100) endPlay(Math.round(nP.y),`${res.cId.toUpperCase()} catches in space and runs into the ENDZONE!`);
                    else endPlay(Math.round(nP.y),`${res.cId.toUpperCase()} catches for ${fmtYds(res.yds)} in space and picks up ${bonus} more before being brought down`);
                  },ANIM);
                }
              }
            },flightMs);
            break;
          }
          case "handoff":{
            setIsRun(true);setBc("rb");setHanded(true);
            const rbR=routes.rb;
            const rbPos=rbR?rbR[cl(phase-1,0,rbR.length-1)]:selPlay.formation.rb;
            setBcP(rbPos);setBallP({...rbPos});setBallSt("held");
            setRunAct(0);setNarr("Handoff to RB!");
            const dp=pursue(defPos,rbPos,1,"rb");setDefPos(dp);
            const arrows=computeRunArrows(rbPos,dp,game,0,"rb",holeInfo,diff);setRunArrows(arrows);
            setCoach(coachRunner(rbPos,dp,arrows,game,coachType));
            animThen(()=>{setPhase(np);setMode("runner");},ANIM);
            break;
          }
          case "statue_handoff":{
            setIsRun(true);setBc("rb");setHanded(true);
            const rbR=routes.rb;
            const rbPos=rbR?rbR[cl(phase-1,0,rbR.length-1)]:selPlay.formation.rb;
            setBcP(rbPos);setBallP({...rbPos});setBallSt("held");
            setRunAct(0);setNarr("STATUE OF LIBERTY! RB takes it!");
            setCoach("üóΩ They didn't see it! RB has the ball ‚Äî find daylight!");
            const dp=pursue(defPos,rbPos,1,"rb");setDefPos(dp);
            const arrows=computeRunArrows(rbPos,dp,game,0,"rb",holeInfo,diff);setRunArrows(arrows);
            animThen(()=>{setPhase(np);setMode("runner");},ANIM);
            break;
          }
          case "tuck_run":{
            setIsRun(true);setBc("qb");setBcP({...qbP});setIsCatch(false);
            setRunAct(0);setNarr("QB tucks and runs!");
            setCoach("üèÉ QB on the move ‚Äî find a gap!");
            const dp=pursue(defPos,qbP,1,"qb");setDefPos(dp);
            const arrows=computeRunArrows(qbP,dp,game,0,"qb",null,diff);setRunArrows(arrows);
            animThen(()=>{setPhase(np);setMode("runner");},ANIM);
            break;
          }
          case "tuck_ball":{
            const loss=rnd(1,3);setPbp(p=>[...p,"Tuck the Ball"]);
            setNarr("QB tucks it and takes the sack.");
            if(isPre(diff))setCoach("Smart play ‚Äî sometimes the best thing is to hold onto the ball and take a small loss.");
            endPlay(-loss,`QB tucks the ball ‚Äî loss of ${loss}`,false,false,"Protected the football by going down safely.");break;
          }
          case "throw_away":{setPbp(p=>[...p,"Throw Away"]);endPlay(0,"Threw it away",false,true,"QB threw the ball away to avoid trouble.");break;}
          case "scramble_lane":{
            // FIX 4 (14.7): QB scramble lane ‚Äî auto-resolved 3-8 yard gain
            const gain=rnd(3,8);setIsRun(true);setBc("qb");setIsCatch(false);
            const nq=R(qbP.x+rnd(-6,6),qbP.y+gain);
            setBcP(nq);setBallP({...nq});setBallSt("held");
            setPbp(p=>[...p,`QB Scramble +${gain}`]);
            setNarr("QB sees a lane and takes off!");
            if(isPre(diff))setCoach("When nobody's open and the pocket is still solid, sometimes the QB can just take off and run.");
            animThen(()=>endPlay(gain,`QB scrambles for ${fmtYds(gain)}`),ANIM);break;
          }
          default:break;
        }
      };

      const checkSack=(ph,mu,nqb,fromPressure)=>{
        const qbPos=nqb||qbP;const closest=nearD(qbPos,defPos);
        // CHANGE 3: Spatial sack ‚Äî uses distance from QB to nearest rusher, not just pocket number
        const lr=getPocketLR(mu);
        const qbSide=qbPos.x<40?"left":qbPos.x>60?"right":"center";
        const sidePkt=qbSide==="left"?lr.left:qbSide==="right"?lr.right:Math.round((lr.left+lr.right)/2);
        // Distance threshold: further from center = more exposed if that side collapsed
        const exposeMod=qbSide!=="center"?(100-sidePkt)/100*0.5:0;
        const effDist=closest.d-exposeMod;
        if(effDist>=3)return "safe";
        if(!fromPressure)return "pressure";
        if(effDist<2){
          const pres=(100-sidePkt)*0.6+ph*8+(defSch.key==="blitz"?15:0)+rnd(-5,5);
          const phFactor=Math.max(0,ph-1);let ch=(pres-25)/100+phFactor*(1-sidePkt/100)*0.12+(sidePkt<30?(30-sidePkt)*0.02:0);
          if(effDist<1.5)ch=Math.min(ch+0.3,0.95);
          if(Math.random()<ch){const l=rnd(3,8);
            const sackFumChance=sidePkt<15?0.20:0;
            if(sackFumChance>0&&Math.random()<sackFumChance){
              if(isPre(diff))setCoach("He held the ball too long. When the pocket is collapsing, tuck the ball to protect it.");
              endPlay(0,`SACKED and FUMBLE! ${closest.p?.lab||"Defender"} strips the ball!`,true,false,"Held the ball too long under heavy pressure ‚Äî the ball came loose.");return "sack";
            }
            endPlay(-l,`SACKED! ${closest.p?.lab||"Defender"} brings down the QB! Loss of ${l}`,false,false,"The pocket collapsed ‚Äî couldn't get the throw off.");return "sack";}
        }
        return "pressure";
      };

      const getPressureOdds=()=>{
        const dp=defPos,qb=qbP;
        const defs=Object.entries(dp).map(([id,p])=>({id,...p,d:dst(qb,p)}));
        const nearby=defs.filter(d=>d.d<5).length;
        const ahead=defs.filter(d=>d.y>qb.y&&d.d<10).length;
        const tuckPct=cl(Math.round(70-nearby*12-ahead*8),10,85);
        const leftDefs=defs.filter(d=>d.x<qb.x-5&&d.d<8).length;
        const rightDefs=defs.filter(d=>d.x>qb.x+5&&d.d<8).length;
        const scrLPct=cl(Math.round(75-leftDefs*18),15,85);
        const scrRPct=cl(Math.round(75-rightDefs*18),15,85);
        return {throwAway:100,tuckRun:tuckPct,scrL:scrLPct,scrR:scrRPct};
      };

      const doPressure=(action)=>{
        const pLabels={throw_away:"Throw Away",tuck_run:"Tuck & Run",scramble_left:"Roll Left",scramble_right:"Roll Right"};
        setPbp(p=>[...p,pLabels[action]||action]);
        const np=phase+1;const mu=degradeMatchups(matchups,defSch);setMatchups(mu);
        if(action==="throw_away"){endPlay(0,"Threw it away under pressure",false,true,"QB threw the ball away to avoid the sack.");return;}
        if(action==="tuck_run"){setIsRun(true);setBc("qb");setBcP({...qbP});setIsCatch(false);setRunAct(0);setPhase(np);setNarr("QB tucks and runs!");setCoach("üèÉ QB scrambles out ‚Äî find a gap!");const dp=pursue(defPos,qbP,1,"qb");setDefPos(dp);const arrows=computeRunArrows(qbP,dp,game,0,"qb",null,diff);setRunArrows(arrows);animThen(()=>setMode("runner"),ANIM);return;}
        if(action==="scramble_left"){const nq=R(cl(qbP.x-rnd(3,4),5,95),qbP.y);setQbP(nq);setPhase(np);setNarr("QB rolls left!");setCoach("Rolling left ‚Äî decide quick!");animThen(()=>{const sr=checkSack(np,mu,nq,true);if(sr==="pressure")setMode("pressure");else if(sr==="safe")setMode("decision");},ANIM);return;}
        if(action==="scramble_right"){const nq=R(cl(qbP.x+rnd(3,4),5,95),qbP.y);setQbP(nq);setPhase(np);setNarr("QB rolls right!");setCoach("Rolling right ‚Äî decide quick!");animThen(()=>{const sr=checkSack(np,mu,nq,true);if(sr==="pressure")setMode("pressure");else if(sr==="safe")setMode("decision");},ANIM);return;}
      };

      const triggerContact=(pos,dp)=>{
        const nd=nearD(pos,dp);
        // FIX 2: Log tackle contact for debugging coordinate mismatches
        const ndDef=dp[nd.id];
        console.log(`[CONTACT] ${nd.p?.lab||nd.id} at ${nd.d.toFixed(2)}yds | Def:(${ndDef?.x.toFixed(1)},${ndDef?.y.toFixed(1)}) BC:(${pos.x.toFixed(1)},${pos.y.toFixed(1)})`);
        const d3=Object.values(dp).filter(d=>dst(pos,d)<4).length;
        const runner=gP(OFF,bc);
        const fumMult=diff==="practice"?0.05:diff==="preseason"?0.3:diff==="regular"?0.7:1.0;
        const tb=tacklesBroken.current;
        const brkPen=tb===0?0:tb===1?15:tb===2?30:45;
        const fumScale=tb===0?1:tb===1?1.5:tb===2?2.5:4;
        const bf=(0.03+d3*0.04)*fumMult*fumScale;
        // Position-aware success rates: 1-on-1 jukes work, can't juke a crowd
        const spinBrk = d3===1 ? cl(Math.round(runner.skl*4.5+8-brkPen),10,55) : d3===2 ? cl(Math.round(runner.skl*3-5-brkPen),5,25) : cl(Math.round(runner.skl*2-10-brkPen),3,15);
        const jukeBrk = d3===1 ? cl(Math.round(runner.skl*4+10-brkPen),10,50) : d3===2 ? cl(Math.round(runner.skl*2.5-brkPen),5,22) : cl(Math.round(runner.skl*1.5-8-brkPen),3,12);
        const stiffBrk = d3===1 ? cl(Math.round(runner.str*4+5-brkPen),8,45) : d3===2 ? cl(Math.round(runner.str*2.5-5-brkPen),5,20) : cl(Math.round(runner.str*1.5-10-brkPen),3,10);
        const options=[
          {type:"spin",label:"üåÄ Spin Move",brk:spinBrk,fum:Math.round(cl((bf+0.08*fumMult*fumScale),0.01,0.50)*100),tck:0},
          {type:"juke",label:"‚ÜôÔ∏è Juke",brk:jukeBrk,fum:Math.round(cl((bf+0.04*fumMult*fumScale),0.01,0.40)*100),tck:0},
          {type:"stiff",label:"üí™ Stiff Arm",brk:stiffBrk,fum:Math.round(cl((bf+0.03*fumMult*fumScale),0.01,0.35)*100),tck:0},
          {type:"dive",label:"‚¨áÔ∏è Dive Forward",brk:0,yds:rnd(1,3),fum:0,tck:0},
        ];
        options.forEach(o=>{o.tck=100-o.brk-o.fum;});
        setContactData({pos,dp,nd,d3,options});
        const bestOpt=options.reduce((a,b)=>b.brk>a.brk?b:a,options[0]);
        setContactFlash({x:pos.x,y:pos.y,label:bestOpt.label.replace(/[^\w\s]/g,"").trim(),brk:bestOpt.brk,fum:bestOpt.fum});
        setTimeout(()=>setContactFlash(null),1200);
        setCoach(coachContact(pos,dp,d3,coachType));
        setMode("contact");
      };

      const resolveContact=opt=>{
        const pos=contactData.pos;
        let yds=Math.round(pos.y);
        const roll=Math.random()*100;
        const cLabel=opt.type==="spin"?"Spin Move":opt.type==="juke"?"Juke":opt.type==="stiff"?"Stiff Arm":"Dive Forward";
        setPbp(p=>[...p,cLabel]);
        if(opt.type==="dive"){
          yds+=opt.yds;
          setBcP(R(pos.x,pos.y+opt.yds));setBallP(R(pos.x,pos.y+opt.yds));endPlay(yds,`Dives for ${fmtYds(yds)}`);
        } else if(roll<opt.fum){
          setNarr(`FUMBLE on the ${opt.type}!`);
          if(isPre(diff)){const tb=tacklesBroken.current;setCoach(`That ${opt.type} had a 1 in ${Math.round(100/opt.fum)} chance of fumbling.${tb>0?` After ${tb} broken tackle${tb>1?"s":""}, Dive Forward was the safe play.`:""}`);}
          endPlay(0,`FUMBLE on the ${opt.type}!`,true);
        } else if(roll<opt.fum+opt.brk){
          const gain=rnd(4,8);
          const nP=R(pos.x+rnd(-8,8),pos.y+gain);
          setBcP(nP);setBallP({...nP});
          tacklesBroken.current++;
          setNarr(`BREAKS FREE! ${opt.type==="spin"?"Spin move!":opt.type==="juke"?"Juke!":"Stiff arm!"}`);
          setCoach("üí• He's loose! Keep running!");
          const ndp=pursue(contactData.dp,nP,runAct+1,bc);
          setDefPos(ndp);setRunAct(r=>r+1);
          const arrows=computeRunArrows(nP,ndp,game,runAct,bc,holeInfo,diff);setRunArrows(arrows);
          if(game.bo+Math.round(nP.y)>=100) endPlay(Math.round(nP.y),"Breaks free into the ENDZONE!");
          else if(tacklesBroken.current>=maxContactsRef.current){
            // FIX 1 (15.1.1): Max contacts ‚Äî check proximity before "brought down"
            const nd2=nearD(nP,ndp);
            if(nd2.d<3){
              animThen(()=>endPlay(Math.round(nP.y),`Brought down for ${fmtYds(Math.round(nP.y))} after breaking free`),ANIM);
            } else {
              // No defender close ‚Äî bonus yards then re-enter runner mode (not phantom end)
              const bonus2=rnd(2,5);
              const fP=R(nP.x+rnd(-3,3),nP.y+bonus2);
              setBcP(fP);setBallP({...fP});
              if(game.bo+Math.round(fP.y)>=100){animThen(()=>endPlay(Math.round(fP.y),"Breaks free into the ENDZONE!"),ANIM);}
              else {
                const ndp2=pursue(ndp,fP,runAct+2,bc);
                setDefPos(ndp2);
                const arrows2=computeRunArrows(fP,ndp2,game,runAct+1,bc,holeInfo,diff);setRunArrows(arrows2);
                setNarr("Breaks free! Still on his feet!");
                animThen(()=>setMode("runner"),ANIM);
              }
            }
          }
          else animThen(()=>setMode("runner"),ANIM);
        } else {
          endPlay(yds,`Brought down for ${fmtYds(yds)} after failed ${opt.type}`);
        }
        setContactData(null);
      };

      const doRun=action=>{
        const ra=runAct+1;
        let np=bcP?{...bcP}:{...qbP};
        setPbp(p=>[...p,action.arrow?action.arrow.label:action.label||"Run"]);
        
        if(action.arrow){
          const arrow=action.arrow;
          // FIX 2: QB "Truck It" has fumble risk
          if(bc==="qb"&&arrow.type==="homerun"&&Math.random()<0.12){
            setNarr("QB tries to truck ‚Äî FUMBLE!");
            setBcP(np);setBallP({...np});setBallSt("loose");
            endPlay(0,"QB fumble trying to truck through!",true);return;
          }
          const roll=Math.random()*100;
          if(roll<arrow.pct){
            const gain=rnd(arrow.ydsLow,arrow.ydsHigh);
            np=R(cl(arrow.targetX+rnd(-3,3),3,97), np.y+Math.max(1,gain));
            setNarr(`${action.label} ‚Äî +${Math.max(1,gain)}!`);
          } else {
            const gain=rnd(0,2);
            np=R(np.x+rnd(-3,3), np.y+gain);
            setNarr(`${action.label} ‚Äî ${gain > 0 ? `+${gain}, fought for it.` : "stuffed."}`);
          }
        } else {
          switch(action.type){
            case "power":{
              // FIX 2: QB slide ends play safely; RB powers forward
              if(bc==="qb"){
                setNarr("QB slides ‚Äî play over.");
                setBcP(np);setBallP({...np});
                endPlay(Math.round(np.y),`QB slides at +${Math.round(np.y)}`);return;
              }
              np=R(np.x,np.y+rnd(1,3));setNarr("Powers forward.");break;
            }
            default:break;
          }
        }

        // CHANGE 5: TD too easy ‚Äî force safety chase on long gains approaching endzone
        const runGain=Math.round(np.y)-(bcP?Math.round(bcP.y):0);
        if(game.bo+Math.round(np.y)>=100){
          // Check if a safety/CB is in range to force a tackle attempt
          const ndp=pursue(defPos,np,ra,bc);
          const chasers=Object.entries(ndp).filter(([did,dp])=>{
            const def=gP(DEF,did);
            return def&&(def.pos==="CB"||def.pos==="S")&&dst(np,dp)<6;
          });
          if(chasers.length>0&&runGain>=8&&tacklesBroken.current<maxContactsRef.current){
            // Safety closes in ‚Äî force contact before endzone
            const stopP=R(np.x,np.y-rnd(1,3)); // Stop just short
            setBcP(stopP);setBallP({...stopP});setRunAct(ra);
            if(bc==="qb")setQbP(stopP);
            setDefPos(ndp);setNarr("Safety closing in at the goal line!");
            animThen(()=>triggerContact(stopP,ndp),ANIM);return;
          }
          setBcP(np);setBallP({...np});setRunAct(ra);
          endPlay(Math.round(np.y),`${bc.toUpperCase()} into the ENDZONE!`);return;
        }

        // CHANGE 5: QB scrambles ‚Äî defender catches up on 10+ yard gains
        if(bc==="qb"&&runGain>=10){
          const ndp=pursue(defPos,np,ra+1,"qb"); // extra pursue step for QB
          const closeD=Object.values(ndp).filter(d=>dst(np,d)<3).length;
          if(closeD>0){
            setBcP(np);setBallP({...np});setQbP(np);setRunAct(ra);
            setDefPos(ndp);setNarr("Defender closing on the QB!");
            if(tacklesBroken.current<maxContactsRef.current){
              animThen(()=>triggerContact(np,ndp),ANIM);return;
            } else {
              animThen(()=>endPlay(Math.round(np.y),`QB brought down for ${fmtYds(Math.round(np.y))}`),ANIM);return;
            }
          }
        }

        setBcP(np);setBallP({...np});
        if(bc==="qb")setQbP(np);
        setRunAct(ra);

        const ndp=pursue(defPos,np,ra,bc);setDefPos(ndp);
        // FIX 2: Use same coordinates as rendering for tackle distance check
        const renderedDef={...ndp};
        if(Object.keys(olPos).length>0){for(const [dl,olId] of Object.entries(OL_BLK)){if(renderedDef[dl]&&olPos[olId]&&renderedDef[dl].y<olPos[olId].y)renderedDef[dl]=R(renderedDef[dl].x,olPos[olId].y);}}
        const nd=nearD(np,renderedDef);
        const arrows=computeRunArrows(np,ndp,game,ra,bc,holeInfo,diff);setRunArrows(arrows);
        setCoach(coachRunner(np,ndp,arrows,game,coachType));

        // FIX 7: Distance-based contact decisions for running
        if(nd.d<2){
          const dp=renderedDef[nd.id];
          console.log(`[TACKLE] ${nd.p?.lab||nd.id} at ${nd.d.toFixed(2)}yds | Def:(${dp?.x.toFixed(1)},${dp?.y.toFixed(1)}) BC:(${np.x.toFixed(1)},${np.y.toFixed(1)})`);
          if(nd.d<=1.5||tacklesBroken.current>=maxContactsRef.current){
            // Immediate tackle ‚Äî no contact decision
            animThen(()=>endPlay(Math.round(np.y),`Brought down for ${fmtYds(Math.round(np.y))}`),ANIM);
          } else {
            animThen(()=>triggerContact(np,renderedDef),ANIM);
          }
          return;
        }

        // YAC REDUCTION: if nobody within 3 yards in open field
        const nearbyCount=Object.values(renderedDef).filter(d=>dst(np,d)<3).length;
        if(nearbyCount===0&&ra>=6){
          // Safety cap ‚Äî 6+ run actions with no defender nearby, auto-end is reasonable
          const bonus=rnd(2,4);
          const finalP=R(np.x+rnd(-3,3),np.y+bonus);
          setBcP(finalP);setBallP({...finalP});
          if(game.bo+Math.round(finalP.y)>=100){endPlay(Math.round(finalP.y),`${bc.toUpperCase()} breaks into the ENDZONE!`);return;}
          endPlay(Math.round(finalP.y),`Runs free for ${fmtYds(Math.round(finalP.y))}`);return;
        }
        // ra < 6 with no nearby defenders: fall through to runner mode below

        animThen(()=>setMode("runner"),ANIM);
      };

      const doFourth=ch=>{
        if (mode !== "fourth") return; 
        if(ch==="punt"){
          setLog(l=>[`üì¢ Punt`,...l].slice(0,25));
          setGame(g=>({...g,bo:25,dn:1,dst:10}));
        }
        else if(ch==="fg"){
          const fgd=100-game.bo+17;
          const mp=fgd<=30?0.95:fgd<=40?0.82:fgd<=50?0.60:fgd<=55?0.35:0.15;
          if(Math.random()<mp){
            setLog(l=>[`ü•Ö FG GOOD! ${fgd}yds`,...l].slice(0,25));
            const oK=offensePlayer===1?"p1":"p2";
            setGame(g=>({...g,bo:25,dn:1,dst:10,sc:{...g.sc,[oK]:g.sc[oK]+3}}));
          }
          else{
            setLog(l=>[`‚ùå FG MISSED ${fgd}yds`,...l].slice(0,25));
            setGame(g=>({...g,bo:25,dn:1,dst:10}));
          }
        } else {setMode("menu");setPCat(null);return;}
        if(twoPlayer) setOffensePlayer(p=>p===1?2:1);
        resetForNew();
        setMode("menu");
      };

      const resetForNew=()=>{
        setSelPlay(null);setDefSch(null);setResult(null);
        setPhase(0);setHanded(false);setBallSt("held");setBallAn(false);
        setCamY(0);setRunAct(0);setNarr("");setCoach("");setDefPos({});
        setOlPos({});setRoutes({});setIsCatch(false);setPCat(null);setShowGhost(false);
        setContactData(null);setRunArrows([]);setHoleInfo(null);setDebrief("");setPbp([]);setRpoData(null);if(commentaryTimer.current)clearTimeout(commentaryTimer.current);setCommentary(null);setPracticeOverlay(null);
        ballFlightRef.current = null;
        setBallFlightPos(null);
        visualPos.current = {};
        stopAnim();
      };

      const advance = () => {
        if (mode !== "result" && mode !== "touchdown") return;
        if (!result) return;
        const r = result;
        setShowTD(false);

        const nb = cl(game.bo + r.yds, 0, 100);
        const gained = nb - game.bo;
        const nd = game.dst - gained;
        let newDn = game.dn + 1;
        let toDowns = false;

        if (r.turnover || r.td || nb >= 100 || nb <= 0) newDn = 1;
        else if (nd <= 0) newDn = 1;
        else if (game.dn >= 4) { newDn = 1; toDowns = true; }

        let logMsg = "";
        if (r.turnover) logMsg = `üí• ${r.desc}`;
        else if (r.td || nb >= 100) logMsg = `üèà TD!`;
        else if (nb <= 0) logMsg = `‚ö†Ô∏è Safety!`;
        else if (nd <= 0) logMsg = `‚úÖ 1st down, ${fmtYds(gained)}`;
        else if (toDowns) logMsg = `‚ùå Turnover on downs`;
        else logMsg = `${fmtYds(gained)} ‚Äî ${r.desc}`;

        setLog(l => [logMsg, ...l].slice(0, 25));

        const oK=offensePlayer===1?"p1":"p2";
        const dK=offensePlayer===1?"p2":"p1";
        const driveOver=!!(r.turnover || r.td || nb >= 100 || nb <= 0 || toDowns);

        setGame(g => {
          let sc = { ...g.sc }, q = g.q, pr = g.pr + 1;
          let lp = [r.yds, ...g.lastPlays].slice(0, 5);
          if (r.td || nb >= 100) sc[oK] += 7;
          if (nb <= 0) sc[dK] += 2;

          let finalBo = nb, finalDst = nd;
          if (driveOver) {
            finalBo = 25; finalDst = 10;
          } else if (nd <= 0) {
            finalDst = Math.min(10, 100 - nb);
          }

          return { bo: finalBo, dn: newDn, dst: finalDst, sc, q: Math.min(4, ~~(pr / 12) + 1), pr, lastPlays: lp };
        });

        if(twoPlayer && driveOver) setOffensePlayer(p=>p===1?2:1);
        resetForNew();
        if (newDn === 4) setMode("fourth");
        else setMode("menu");
      };

      const getQBActions=()=>{
        const a=[];
        for(const id of ["wr1","wr2","te","rb"]){
          if(id==="rb"&&handed)continue;
          const pos=offP[id];if(!pos)continue;
          const pr=throwProbs(id,phase,offP,defPos,defSch,pi,lookDir,diff);
          a.push({type:"throw",target:id,cat:"throw",label:id.toUpperCase(),sub:`${Math.round(pos.y)>0?"+":""}${Math.round(pos.y)}yds`,op:pr.op,cp:pr.cp,ip:pr.ip});
        }
        // Contextual button labels based on phase ‚Äî always labeled "Drop Back" so players recognize it
        // FIX 6 (15.0): "Drop Back" at Phase 1, "Wait" at Phase 2+
        const dbLabel=phase<=1?(isPre(diff)?"Drop Back (run the play)":"Drop Back"):"Wait";
        const dbSub=phase<=1?"Receivers still running routes":pi<30?"‚ö†Ô∏è Pocket collapsing ‚Äî risky!":pi<50?"‚ö†Ô∏è Pressure building":"Let the routes develop";
        a.push({type:"dropback",cat:"move",label:dbLabel,sub:dbSub});
        // Roll only appears phase 2+ when pressure exists
        const weakSide=getWeak(matchups);
        const pressureLeft=weakSide.id==="de1"||weakSide.id==="olb1";
        const pressureRight=weakSide.id==="de2"||weakSide.id==="olb2";
        if(phase>=2&&(pi<70||pressureLeft||pressureRight)){
          const leftRecs=["wr1","te"].filter(id=>offP[id]&&offP[id].x<40).map(id=>`${fmtTarget(id)} (${opn(id,offP,defPos,defSch).lab})`).join(", ");
          const rightRecs=["wr2","te"].filter(id=>offP[id]&&offP[id].x>60).map(id=>`${fmtTarget(id)} (${opn(id,offP,defPos,defSch).lab})`).join(", ");
          if(pressureRight||!pressureLeft) a.push({type:"scramble_left",cat:"move",label:"Roll Left",sub:pressureRight?`Move away from pressure${leftRecs?". "+leftRecs:""}`:leftRecs||"Roll left"});
          if(pressureLeft||!pressureRight) a.push({type:"scramble_right",cat:"move",label:"Roll Right",sub:pressureLeft?`Escape the rush${rightRecs?". "+rightRecs:""}`:rightRecs||"Roll right"});
        }
        const cMu=Object.values(matchups).find(m=>m.olId==="c");
        if(!cMu||cMu.integrity>30) a.push({type:"step_up",cat:"move",label:"Step Up",sub:"Forward through gap"});
        if(!lookDir){
          const leftRecInfo=["wr1","te"].filter(id=>offP[id]&&offP[id].x<45).map(id=>`${fmtTarget(id)} (${opn(id,offP,defPos,defSch).lab})`).join(", ");
          const rightRecInfo=["wr2","te"].filter(id=>offP[id]&&offP[id].x>55).map(id=>`${fmtTarget(id)} (${opn(id,offP,defPos,defSch).lab})`).join(", ");
          const lookLSub=leftRecInfo||"W1 and TE on this side";
          const lookRSub=rightRecInfo||"W2 on this side";
          a.push({type:"look_left",cat:"look",label:"üëÄ Look Left",sub:lookLSub+(isPre(diff)?" ‚Äî pulls safety left, RIGHT side opens up":"")});
          a.push({type:"look_right",cat:"look",label:"üëÄ Look Right",sub:lookRSub+(isPre(diff)?" ‚Äî draws safety right, LEFT side opens up":"")});
        }
        if(!handed&&phase<=2)a.push({type:"handoff",cat:"other",label:"Hand Off",sub:"Give to RB"});
        if(selPlay?.statue&&!handed)a.push({type:"statue_handoff",cat:"trick",label:"üóΩ Statue!",sub:"Slip to RB"});
        if(pi<30&&phase>=3) a.push({type:"tuck_ball",cat:"tuck",label:"üèà TUCK THE BALL",sub:"Small loss, zero fumble risk"});
        a.push({type:"tuck_run",cat:"other",label:"Tuck & Run",sub:"QB keeps it"});
        a.push({type:"throw_away",cat:"escape",label:"üèà Throw Away",sub:"Incomplete, no INT"});
        // FIX 4 (14.7): QB scramble lane ‚Äî ~1/8 chance when all receivers covered and pocket decent
        if(scrambleLaneRef.current.phase!==phase){
          const allCovered=["wr1","wr2","te","rb"].every(id=>{if(id==="rb"&&handed)return true;const o=opn(id,offP,defPos,defSch);return o.o<2;});
          scrambleLaneRef.current={phase,open:allCovered&&pi>50&&Math.random()<0.125};
        }
        if(scrambleLaneRef.current.open){
          a.push({type:"scramble_lane",cat:"scramble",label:"üèÉ QB Scramble",sub:"Lane is open! +3-8 yards"});
        }
        return a;
      };

      const getRunActions=()=>{
        const a=[];
        const isQB = bc === "qb";
        const isRec = bc === "wr1" || bc === "wr2" || bc === "te";
        for(const arrow of runArrows){
          let label = arrow.label, sub = arrow.sub;
          if(isQB){
            if(arrow.type==="sure"){label="Sprint Upfield";sub=`~${arrow.ydsHigh-2} yards, get north`;}
            else if(arrow.type==="gamble"){label="Cut Outside";sub=`${arrow.ydsHigh} yards if clear, risky`;}
            else if(arrow.type==="homerun"){label="Truck It";sub=`Low odds, big gain, possible fumble`;}
          }
          // RB/WR/TE: use labels from computeRunArrows directly (Sprint, Cut Outside, Juke)
          a.push({type:"arrow",arrow,label,sub,pct:arrow.pct,color:arrow.color});
        }
        if(isQB){
          a.push({type:"power",label:"‚¨áÔ∏è Slide",sub:"End play safely, keep yardage",pct:100,color:"#8a9ab0"});
        } else if(isRec){
          a.push({type:"power",label:"‚¨áÔ∏è Dive Forward",sub:"+1-3 yards, safe",pct:85,color:"#8a9ab0"});
        } else if(bcP && bcP.y >= 3){
          a.push({type:"power",label:"‚¨áÔ∏è Dive Forward",sub:"+1-3 yards, safe",pct:85,color:"#8a9ab0"});
        } else {
          a.push({type:"power",label:"‚¨áÔ∏è Power Forward",sub:"+1-3 yards, safe",pct:85,color:"#8a9ab0"});
        }
        return a;
      };

      // Player shape helpers: OL=shield, DL=wedge, QB=diamond, RB=rounded rect, WR/DB=circle, TE=rounded square, LB=hexagon
      const getPlayerShape=(pos,isOff)=>{
        if(pos==="OL") return {w:28,h:22,br:"4px 4px 10px 10px",clip:""};       // Shield: flat top, rounded bottom
        if(pos==="DL") return {w:26,h:26,br:"4px",clip:"polygon(50% 0%, 100% 35%, 100% 100%, 0% 100%, 0% 35%)"}; // Wedge
        if(pos==="QB") return {w:28,h:28,br:"4px",clip:"polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)"}; // Diamond
        if(pos==="RB") return {w:28,h:24,br:"8px",clip:""};                      // Rounded rect
        if(pos==="WR") return {w:26,h:26,br:"50%",clip:""};                      // Circle
        if(pos==="TE") return {w:28,h:28,br:"6px",clip:""};                      // Rounded square
        if(pos==="LB") return {w:28,h:26,br:"4px",clip:"polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)"}; // Hexagon
        if(pos==="CB"||pos==="S") return {w:26,h:26,br:"50%",clip:""};           // Circle
        return {w:28,h:28,br:"50%",clip:""};
      };

      const renderPlayer=(id,pos,team)=>{
        if(!pos)return null;
        const isOff=team==="off",rost=isOff?OFF:DEF;
        const p=gP(rost,id);if(!p)return null;
        const isOL=p.pos==="OL";
        const hasBall=isOff&&ballSt==="held"&&id===bc&&!["diff_select","menu","playcall","presnap"].includes(mode);
        const key=`${team}-${id}`;
        const vp=(hasBall&&bcP)?bcP:(visualPos.current[key]||pos);
        const px=xS(vp.x),py=yS(vp.y);
        if(py<-40||py>FH+40)return null;
        const shape=getPlayerShape(p.pos,isOff);
        const {w,h}=shape;
        let olC="#2a5a90";
        if(isOL&&!["diff_select","menu","playcall","fourth"].includes(mode)){
          const mu=Object.values(matchups).find(m=>m.olId===id);
          if(mu)olC=mu.integrity>60?"#2a7a40":mu.integrity>30?"#8a6a20":"#8a2020";
        }
        let bdr=isOff?(isOL?"#5588bb":"#4a8ad4"):(p.pos==="DL"?"#b33":"#e05555");
        if(hasBall)bdr="#fbbf24";
        const bg=isOff?(isOL?olC:"#1e56a0"):(p.pos==="DL"?"#7a1a1a":"#b82020");
        const stl={
          position:"absolute",left:px-w/2,top:py-h/2,width:w,height:h,
          borderRadius:shape.clip?"4px":shape.br,
          clipPath:shape.clip||"none",
          background:bg,
          border:shape.clip?"none":`${hasBall?3:2}px solid ${bdr}`,
          display:"flex",alignItems:"center",justifyContent:"center",
          fontSize:isOL?7:9,fontWeight:700,color:"#fff",zIndex:isOL?9:10,
          fontFamily:"monospace",boxShadow:"0 1px 3px rgba(0,0,0,0.5)"
        };
        if(shape.clip){
          stl.boxShadow=`0 0 0 ${hasBall?3:2}px ${bdr}, 0 1px 3px rgba(0,0,0,0.5)`;
        }
        return(<div key={key} ref={el=>{if(el)playerElRefs.current[key]=el;}} style={stl}>{p.lab}</div>);
      };

      const renderBcOverlay=()=>{
        if(!bcP||!isRun||bc==="qb"||mode==="menu"||mode==="playcall"||ballSt!=="held")return null;
        const sz=32,px=xS(bcP.x),py=yS(bcP.y);
        if(py<-40||py>FH+40)return null;
        return(<div style={{position:"absolute",left:px-sz/2,top:py-sz/2,width:sz,height:sz,borderRadius:"50%",
          background:"#1e56a0",border:"3px solid #fbbf24",display:"flex",alignItems:"center",justifyContent:"center",
          fontSize:9,fontWeight:700,color:"#fff",zIndex:12,fontFamily:"monospace"
        }}>{gP(OFF,bc)?.lab}</div>);
      };

      const renderBall=()=>{
        if(["diff_select","menu","playcall","fourth"].includes(mode))return null;
        const bpos=(ballSt==="air"&&ballFlightPos)?ballFlightPos:ballP;
        const bx=xS(bpos.x),by=yS(bpos.y);
        if(by<-40||by>FH+40)return null;
        const isAir=ballSt==="air",isHeld=ballSt==="held";
        return(<>
          <div style={{position:"absolute",left:bx-10,top:by-10+(isHeld?-18:0),width:20,height:20,display:"flex",alignItems:"center",justifyContent:"center",
            fontSize:isAir?18:15,zIndex:isAir?25:isHeld?20:16,
            transform:`${ballSt==="ground"?"rotate(45deg)":ballSt==="loose"?"rotate(120deg)":isAir?"rotate(-30deg)":"rotate(-15deg)"} scale(${isAir?1.3:1})`,
            filter:isAir?"drop-shadow(0 4px 8px rgba(0,0,0,0.6))":isHeld?"drop-shadow(0 1px 2px rgba(0,0,0,0.4))":"none",
            opacity:ballSt==="ground"||ballSt==="loose"?0.7:1,pointerEvents:"none"}}>üèà</div>
          {isHeld&&<div style={{position:"absolute",left:bx-18,top:by-18,width:36,height:36,borderRadius:"50%",
            border:"2px solid rgba(251,191,36,0.5)",zIndex:13,animation:"pulse 1.5s ease-in-out infinite",pointerEvents:"none"}}/>}
        </>);
      };

      const renderGhosts=()=>{
        if(!showGhost||!selPlay||!routes||!["presnap","playcall"].includes(mode))return null;
        const f=selPlay.formation;
        return Object.entries(routes).map(([id,route])=>{
          if(!route||!f[id])return null;
          const color=id==="rb"?"#f97316":"#4a9eff";
          const points=[f[id],...route];
          return points.slice(0,-1).map((pt,i)=>{
            const next=points[i+1];
            const x1=xS(pt.x),y1=yS(pt.y),x2=xS(next.x),y2=yS(next.y);
            if(y1<-40||y1>FH+40||y2<-40||y2>FH+40)return null;
            const angle=Math.atan2(y2-y1,x2-x1)*180/Math.PI;
            const len=Math.sqrt((x2-x1)**2+(y2-y1)**2);
            return(<div key={`g-${id}-${i}`} style={{
              position:"absolute",left:x1,top:y1,width:len,height:2,
              background:color,opacity:0.5,transformOrigin:"0 50%",
              transform:`rotate(${angle}deg)`,zIndex:6,pointerEvents:"none",
            }}>{i===points.length-2&&<div style={{position:"absolute",right:-4,top:-3,width:0,height:0,
              borderLeft:`8px solid ${color}`,borderTop:"4px solid transparent",borderBottom:"4px solid transparent",opacity:0.7}}/>}</div>);
          });
        });
      };

      const renderRunArrows=()=>{
        if(!runArrows.length||!bcP||!["runner"].includes(mode))return null;
        const bx=xS(bcP.x),by=yS(bcP.y);
        return runArrows.map((arrow,i)=>{
          const tx=xS(arrow.targetX),ty=yS(arrow.targetY);
          if(ty<-40||ty>FH+40)return null;
          const angle=Math.atan2(ty-by,tx-bx)*180/Math.PI;
          const len=Math.sqrt((tx-bx)**2+(ty-by)**2);
          return(<div key={`ra-${i}`} style={{
            position:"absolute",left:bx,top:by,width:len,height:3,
            background:arrow.color,opacity:0.6,transformOrigin:"0 50%",
            transform:`rotate(${angle}deg)`,zIndex:7,pointerEvents:"none",
          }}><div style={{position:"absolute",right:-5,top:-4,width:0,height:0,
            borderLeft:`10px solid ${arrow.color}`,borderTop:"5px solid transparent",borderBottom:"5px solid transparent",opacity:0.8}}/></div>);
        });
      };

      const dlS=["","1st","2nd","3rd","4th"][game.dn]||"4th";
      const pcPlays = pCat ? (PLAYS[pCat]||[]) : [];
      const pcStaples = pcPlays.filter(p=>!p.cat||p.cat==="staple");
      const pcSituational = pcPlays.filter(p=>p.cat==="situational");
      const pcSpecial = pcPlays.filter(p=>p.cat==="special");
      const blS=game.bo>50?`OPP ${100-game.bo}`:`OWN ${game.bo}`;
      const btn={border:"none",borderRadius:6,cursor:"pointer",fontFamily:"inherit",transition:"all 0.1s"};
      const findSuggestions=(defKey)=>{
        if(!defKey)return[];
        const dn=game.dn, ydg=game.dst;
        const all=[...PLAYS.run,...PLAYS.pass,...PLAYS.trick];
        // Filter by down/distance appropriateness
        const appropriate=all.filter(p=>{
          if(p.qbSneak&&(dn<3||ydg>3))return false; // QB Sneak only on 3rd/4th & 1-3
          if(ydg>=7&&p.qbSneak)return false; // Never sneak on long yardage
          if(ydg>=7&&p.name==="Power Run")return false; // Power Run caps at ~3 yds
          return true;
        });
        const good=appropriate.filter(p=>(MX[p.name]?.[defKey]||0)>=1);
        const pool=good.length>=2?good:appropriate.filter(p=>(MX[p.name]?.[defKey]||0)>=0);
        const runs=pool.filter(p=>p.type==="run"), passes=pool.filter(p=>p.type==="pass"||p.type==="trick");
        const picks=[];
        if(ydg>=7){
          // Long yardage: prefer pass plays
          if(passes.length>=2){picks.push(pick(passes));const rem=passes.filter(p=>p!==picks[0]);if(rem.length)picks.push(pick(rem));}
          else if(passes.length&&runs.length){picks.push(pick(passes));picks.push(pick(runs));}
          else{const fp=[...pool];if(fp.length>=2){picks.push(fp.splice(Math.floor(Math.random()*fp.length),1)[0]);picks.push(fp[Math.floor(Math.random()*fp.length)]);}else if(fp.length===1)picks.push(fp[0]);}
        } else {
          if(runs.length&&passes.length){picks.push(pick(runs));picks.push(pick(passes));}
          else{const fp=[...pool];if(fp.length>=2){picks.push(fp.splice(Math.floor(Math.random()*fp.length),1)[0]);picks.push(fp[Math.floor(Math.random()*fp.length)]);}else if(fp.length===1)picks.push(fp[0]);}
        }
        return picks;
      };
      let displayDefPos = defPos || {};
      if (!defSch && ["diff_select", "menu", "playcall", "fourth"].includes(mode)) {
        displayDefPos = DEFS.base43.pos;
      } else if(Object.keys(olPos).length>0){
        const clamped={...displayDefPos};
        for(const [dl,olId] of Object.entries(OL_BLK)){
          if(clamped[dl]&&olPos[olId]&&clamped[dl].y<olPos[olId].y) clamped[dl]=R(clamped[dl].x,olPos[olId].y);
        }
        displayDefPos=clamped;
      }

      const nd=(bcP||(isRun&&bc==="qb"))?nearD(bcP||qbP,displayDefPos):null;
      const fgD=100-game.bo+17;
      const pLR=getPocketLR(matchups);
      const pColL=pLR.left>60?"#22c55e":pLR.left>30?"#fbbf24":"#ef4444";
      const pColR=pLR.right>60?"#22c55e":pLR.right>30?"#fbbf24":"#ef4444";
      const pCol=pi>60?"#22c55e":pi>30?"#fbbf24":"#ef4444";

      return(
        <div style={{fontFamily:"'SF Mono','Cascadia Code','Courier New',monospace",background:"#080c14",color:"#d0dce8",minHeight:"100vh",padding:"10px 10px 40px"}}>
          <style>{`
            @keyframes pulse{0%,100%{opacity:0.4;transform:scale(1)}50%{opacity:0.8;transform:scale(1.08)}}
            @keyframes fw{0%{transform:translate(0,0) scale(1);opacity:1}100%{transform:translate(var(--dx),var(--dy)) scale(0);opacity:0}}
            @keyframes tdBounce{0%{transform:scale(0) rotate(-10deg);opacity:0}50%{transform:scale(1.15) rotate(3deg);opacity:1}100%{transform:scale(1) rotate(0);opacity:1}}
            @keyframes tdGlow{0%,100%{text-shadow:0 0 20px #fbbf24,0 0 40px #f97316}50%{text-shadow:0 0 40px #fbbf24,0 0 80px #f97316,0 0 120px #ef4444}}
            @keyframes contactPulse{0%,100%{box-shadow:0 0 20px rgba(239,68,68,0.3)}50%{box-shadow:0 0 40px rgba(239,68,68,0.6)}}
            @keyframes qbGlow{0%,100%{box-shadow:none}50%{box-shadow:0 0 12px rgba(74,158,255,0.6)}}
            @keyframes alertFade{0%{opacity:1;transform:translate(-50%,-50%) scale(1.15)}15%{opacity:1;transform:translate(-50%,-50%) scale(1)}70%{opacity:0.9;transform:translate(-50%,-50%) scale(1)}100%{opacity:0;transform:translate(-50%,-50%) scale(0.95)}}
          `}</style>

          {/* DIFFICULTY AND COACH SELECT */}
          {mode==="diff_select"&&(
            <div style={{maxWidth:FW,margin:"40px auto",textAlign:"center"}}>
              <div style={{fontSize:40,fontWeight:900,color:"#fbbf24",marginBottom:4}}>üèà TACTICAL FOOTBALL</div>
              <div style={{fontSize:22,color:"#fff",fontWeight:800,marginBottom:6,letterSpacing:1}}>{GAME_VERSION}</div>
              <div style={{fontSize:15,color:"#c8b090",fontWeight:500,marginBottom:6,lineHeight:1.6,maxWidth:560,margin:"0 auto 6px",textAlign:"left"}}>
                Learn football terminology and play-calling from scratch (Practice and Preseason), or test yourself against realistic defenses (Regular Season and Playoffs). A turn-based tactical football game ‚Äî I wanted a game like this and couldn't find one.
              </div>
              <div style={{fontSize:15,color:"#c8b090",fontWeight:500,marginBottom:10,lineHeight:1.6,maxWidth:560,margin:"0 auto 10px",textAlign:"left"}}>
                Development road map includes two player games, more trick plays, and maybe cheerleaders (not that you'll see them... but you'll know they're there).
              </div>
              <div style={{fontSize:14,color:"#d4a060",fontWeight:500,marginBottom:6,fontStyle:"italic"}}>This needs LOTS of bug fixes and improvements. You can help.</div>
              <a href="https://forms.gle/xAmyf1rkkG71PtrS8" target="_blank" rel="noopener noreferrer" style={{display:"inline-block",padding:"8px 20px",background:"#2a1a00",border:"2px solid #d4a060",borderRadius:6,color:"#fbbf24",fontSize:14,fontWeight:700,textDecoration:"none",marginBottom:16,cursor:"pointer"}}>üìù Give Feedback Here</a>
              
              {!coachType ? (
                <>
                  <div style={{fontSize:22,color:"#8aa0b8",marginBottom:24,fontWeight:700}}>Select Your Head Coach</div>
                  <div style={{display:"flex",gap:12,justifyContent:"center",flexWrap:"wrap",maxWidth:620,margin:"0 auto 24px"}}>
                    <button onClick={()=>setCoachType("A")} style={{...btn,minWidth:280,flex:"1 1 280px",padding:"16px 20px",background:"#0e1520",border:"2px solid #4a9eff",color:"#d0dce8",textAlign:"left"}}>
                      <div style={{textAlign:"center",marginBottom:8}}>
                        <svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
                          <circle cx="32" cy="28" r="14" fill="#1a2a44"/>
                          <circle cx="32" cy="24" r="10" fill="#c8a882"/>
                          <ellipse cx="32" cy="22" rx="10" ry="4" fill="#2a4a7a"/>
                          <rect x="22" y="18" width="20" height="4" rx="2" fill="#2a4a7a"/>
                          <rect x="19" y="20" width="6" height="3" rx="1" fill="#2a4a7a"/>
                          <circle cx="28" cy="26" r="1.5" fill="#1a1a2a"/>
                          <circle cx="36" cy="26" r="1.5" fill="#1a1a2a"/>
                          <path d="M29 30 Q32 33 35 30" stroke="#1a1a2a" strokeWidth="1.5" fill="none"/>
                          <rect x="24" y="38" width="16" height="20" rx="4" fill="#4a9eff"/>
                          <text x="32" y="52" textAnchor="middle" fill="#fff" fontSize="10" fontWeight="bold">JOE</text>
                        </svg>
                      </div>
                      <div style={{fontSize:18,fontWeight:800,color:"#4a9eff"}}>Baby Boy Joey ‚Äî The Gunslinger</div>
                      <div style={{fontSize:15,color:"#8a9ab0",marginTop:6,lineHeight:1.5}}>Young, cocksure, and always scheming. Calls plays that make defensive coordinators swear. When they work, they're spectacular ‚Äî and when they don't, his grit and hustle already have the next one drawn up.</div>
                    </button>
                    <button onClick={()=>setCoachType("B")} style={{...btn,minWidth:280,flex:"1 1 280px",padding:"16px 20px",background:"#0e1520",border:"2px solid #22c55e",color:"#d0dce8",textAlign:"left"}}>
                      <div style={{textAlign:"center",marginBottom:8}}>
                        <svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
                          <circle cx="32" cy="26" r="14" fill="#2a1a0a"/>
                          <circle cx="32" cy="24" r="11" fill="#c8a882"/>
                          <rect x="24" y="18" width="16" height="6" rx="3" fill="#8B4513"/>
                          <rect x="25" y="19" width="5" height="5" rx="1" fill="#aad4ff" stroke="#666" strokeWidth="0.5"/>
                          <rect x="34" y="19" width="5" height="5" rx="1" fill="#aad4ff" stroke="#666" strokeWidth="0.5"/>
                          <path d="M27 30 Q32 34 37 30" stroke="#5a3a1a" strokeWidth="2.5" fill="none"/>
                          <ellipse cx="32" cy="29" rx="5" ry="2" fill="#5a3a1a"/>
                          <circle cx="28" cy="23" r="1.2" fill="#1a1a2a"/>
                          <circle cx="36" cy="23" r="1.2" fill="#1a1a2a"/>
                          <rect x="22" y="38" width="20" height="22" rx="5" fill="#b8860b"/>
                          <circle cx="14" cy="24" r="4" fill="#333" stroke="#666" strokeWidth="1"/>
                          <line x1="14" y1="24" x2="22" y2="26" stroke="#666" strokeWidth="1.5"/>
                          <text x="32" y="53" textAnchor="middle" fill="#fff" fontSize="10" fontWeight="bold">JIM</text>
                        </svg>
                      </div>
                      <div style={{fontSize:18,fontWeight:800,color:"#22c55e"}}>Grizzled Jim ‚Äî The Old Fox</div>
                      <div style={{fontSize:15,color:"#8a9ab0",marginTop:6,lineHeight:1.5}}>Forty years on the sideline. Players run through walls for him. Knows the game cold, never panics, and a steadying presence when things get crazy.</div>
                    </button>
                  </div>
                </>
              ) : (
                <>
                  <div style={{display:"flex",justifyContent:"center",gap:0,marginBottom:20}}>
                    <button onClick={()=>setTwoPlayer(false)} style={{...btn,padding:"10px 28px",fontSize:16,fontWeight:800,borderRadius:"8px 0 0 8px",border:"2px solid #4a9eff",background:!twoPlayer?"#4a9eff":"#0e1520",color:!twoPlayer?"#000":"#4a9eff"}}>1 PLAYER</button>
                    <button onClick={()=>setTwoPlayer(true)} style={{...btn,padding:"10px 28px",fontSize:16,fontWeight:800,borderRadius:"0 8px 8px 0",border:"2px solid #a855f7",borderLeft:"none",background:twoPlayer?"#a855f7":"#0e1520",color:twoPlayer?"#000":"#a855f7"}}>2 PLAYER</button>
                  </div>
                  {twoPlayer&&<div style={{fontSize:13,color:"#a855f7",marginBottom:12,fontStyle:"italic"}}>Pass the device ‚Äî one calls offense, one picks defense.</div>}
                  <div style={{fontSize:22,color:"#8aa0b8",marginBottom:24,fontWeight:700}}>Choose Your Difficulty</div>
                  <div style={{display:"flex",gap:10,flexDirection:"column",maxWidth:400,margin:"0 auto"}}>
                    {[
                      ...(!twoPlayer?[{key:"practice",label:"Practice (Team Practice)",desc:
            "Learn every part of football step by step. The game pauses and explains each decision. No pressure, no score ‚Äî just learning.",
          col:"#4a9eff"}]:[]),
                      {key:"preseason",label:"Preseason",desc:
            "Learn the game. Coach explains every position, every play, and why matchups matter. Perfect if you're new to football.",
          col:"#22c55e"},
                      {key:"regular",label:"Regular Season",desc:
            "You know the basics. Coach steps back, training wheels come off. You make the reads.",
          col:"#fbbf24"},
                      {key:"playoffs",label:"Playoffs",desc:
            "No help. Pure football IQ.",
          col:"#ef4444"},
                    ].map(d=>(<button key={d.key} onClick={()=>{setDiff(d.key);if(twoPlayer)setOffensePlayer(1);setMode("menu");}} style={{...btn,padding:"18px 22px",background:"#0e1520",border:`2px solid ${d.col}44`,color:d.col,textAlign:"left"}}>
                      <div style={{fontSize:18,fontWeight:800}}>{d.label}</div>
                      <div style={{fontSize:16,color:"#8a9ab0",marginTop:4,lineHeight:1.5}}>{d.desc}</div>
                    </button>))}
                  </div>
                </>
              )}
            </div>
          )}

          {mode!=="diff_select"&&<>
          {/* SCOREBOARD + VERSION + MENU */}
          <div style={{display:"flex",justifyContent:"space-between",alignItems:"center",padding:"4px 14px",background:"#10151f",borderRadius:6,border:"1px solid #1a2540",maxWidth:FW,margin:"0 auto 2px"}}>
            <div style={{display:"flex",gap:20,alignItems:"center"}}>
              <div style={{textAlign:"center"}}><div style={{fontSize:10,color:"#4a9eff",fontWeight:700}}>{twoPlayer?"P1":"YOU"}{twoPlayer&&offensePlayer===1?" üèà":""}</div><div style={{fontSize:24,fontWeight:800,color:"#4a9eff"}}>{game.sc.p1}</div></div>
              <div style={{color:"#2a3550"}}>vs</div>
              <div style={{textAlign:"center"}}><div style={{fontSize:10,color:"#ef4444",fontWeight:700}}>{twoPlayer?"P2":"CPU"}{twoPlayer&&offensePlayer===2?" üèà":""}</div><div style={{fontSize:24,fontWeight:800,color:"#ef4444"}}>{game.sc.p2}</div></div>
            </div>
            <div style={{textAlign:"center"}}><div style={{fontSize:14,fontWeight:800,color:"#fbbf24",letterSpacing:1}}>{GAME_VERSION}</div></div>
            <div style={{display:"flex",alignItems:"center",gap:10}}>
              <div style={{textAlign:"right"}}><div style={{fontSize:14,fontWeight:700}}>{dlS} & {game.dst}</div><div style={{fontSize:11,color:"#5a7090"}}>{blS} ¬∑ Q{game.q}</div></div>
              <button onClick={()=>setSfxMuted(m=>!m)} title={sfxMuted?"Unmute":"Mute"} style={{...btn,padding:"6px 10px",background:"#1a2540",border:"1px solid #4a6080",color:sfxMuted?"#6a7a90":"#d0dce8",fontSize:12,fontWeight:700,cursor:"pointer",borderRadius:6}}>{sfxMuted?"üîá":"üîä"}</button>
              <button onClick={()=>setShowMenuConfirm(true)} style={{...btn,padding:"6px 10px",background:"#1a2540",border:"1px solid #4a6080",color:"#d0dce8",fontSize:12,fontWeight:700,cursor:"pointer",borderRadius:6}}>‚ò∞</button>
            </div>
          </div>

          {/* MENU CONFIRMATION DIALOG */}
          {showMenuConfirm&&(
            <div style={{maxWidth:FW,margin:"0 auto 8px",padding:"14px 16px",background:"rgba(10,15,30,0.97)",borderRadius:8,border:"2px solid #f97316",textAlign:"center"}}>
              <div style={{fontSize:13,color:"#f97316",fontWeight:700,marginBottom:8}}>Return to main menu?</div>
              <div style={{fontSize:11,color:"#8a9ab0",marginBottom:12}}>Current game will be lost.</div>
              <div style={{display:"flex",gap:8,justifyContent:"center"}}>
                <button onClick={()=>{setShowMenuConfirm(false);setCoachType(null);setDiff(null);setTwoPlayer(false);setOffensePlayer(1);setGame({bo:25,dn:1,dst:10,sc:{p1:0,p2:0},q:1,pr:0,lastPlays:[]});resetForNew();setLog([]);practiceShown.current=new Set();tuckWarnings.current=0;setMode("diff_select");}} style={{...btn,padding:"8px 24px",background:"#f97316",color:"#000",fontSize:13,fontWeight:800}}>Yes</button>
                <button onClick={()=>setShowMenuConfirm(false)} style={{...btn,padding:"8px 24px",background:"#10151f",border:"1px solid #2a3550",color:"#8a9ab0",fontSize:13,fontWeight:700}}>No</button>
              </div>
            </div>
          )}

          {/* FIELD */}
          <div style={{position:"relative",width:FW,height:FH,margin:"0 auto",background:"#1e6830",borderRadius:6,overflow:"hidden",border:"2px solid #2a8040"}}>
            {/* Alternating turf stripes ‚Äî every 5 yards, two subtle greens (playing field only) */}
            {Array.from({length:30},(_,i)=>{
              const stripeYd = (i - 14) * 5 + Math.floor(effectiveCamY / 5) * 5;
              const fieldYd = game.bo + stripeYd;
              if(fieldYd < 0 || fieldYd >= 100) return null;
              const topY = yS(stripeYd + 5), botY = yS(stripeYd);
              const t = Math.min(topY, botY), h = Math.abs(botY - topY);
              if(t > FH + 10 || t + h < -10) return null;
              const stripeIdx = Math.floor((fieldYd) / 5);
              const col = stripeIdx % 2 === 0 ? "#2d5a1e" : "#326320";
              return <div key={`ts${i}`} style={{position:"absolute",left:0,right:0,top:t,height:h,background:col,zIndex:0}}/>;
            })}
            {/* Opponent end zone ‚Äî dark red with diagonal stripes */}
            {(()=>{const gy=yS(100-game.bo),ezy=yS(110-game.bo),t=Math.min(gy,ezy),h=Math.abs(gy-ezy);return(t<FH+10&&t+h>-10)?<div style={{position:"absolute",left:0,right:0,top:t,height:h,background:"#6a1a1a",zIndex:1,overflow:"hidden"}}><div style={{position:"absolute",inset:-20,background:"repeating-linear-gradient(45deg,transparent,transparent 12px,rgba(255,255,255,0.06) 12px,rgba(255,255,255,0.06) 24px)"}}/><div style={{position:"absolute",top:"50%",left:"50%",transform:"translate(-50%,-50%)",fontSize:16,fontWeight:900,letterSpacing:8,color:"rgba(255,255,255,0.35)",fontFamily:"'Segoe UI',Arial,sans-serif",textShadow:"0 2px 4px rgba(0,0,0,0.5)"}}>END ZONE</div></div>:null;})()}
            {/* Own end zone ‚Äî dark blue with diagonal stripes */}
            {(()=>{const gy=yS(-game.bo),ezy=yS(-game.bo-10),t=Math.min(gy,ezy),h=Math.abs(gy-ezy);return(t<FH+10&&t+h>-10)?<div style={{position:"absolute",left:0,right:0,top:t,height:h,background:"#1a2a5a",zIndex:1,overflow:"hidden"}}><div style={{position:"absolute",inset:-20,background:"repeating-linear-gradient(45deg,transparent,transparent 12px,rgba(255,255,255,0.06) 12px,rgba(255,255,255,0.06) 24px)"}}/><div style={{position:"absolute",top:"50%",left:"50%",transform:"translate(-50%,-50%)",fontSize:16,fontWeight:900,letterSpacing:8,color:"rgba(255,255,255,0.25)",fontFamily:"'Segoe UI',Arial,sans-serif",textShadow:"0 2px 4px rgba(0,0,0,0.5)"}}>END ZONE</div></div>:null;})()}
            {/* Yard lines ‚Äî full field coverage */}
            {Array.from({length:50},(_,i)=>{
              const yo=(i-24.5)*2.5+effectiveCamY;const y=yS(yo);if(y<-10||y>FH+10)return null;
              const num=Math.round(game.bo+yo);const d=num>50?100-num:num;const rd=Math.round(d);
              if(num<0||num>100)return null;
              const is10=rd%10===0&&rd>=0&&rd<=50;const is5=rd%5===0&&!is10&&rd>=0&&rd<=50;
              return(<div key={`yl${i}`}>
                {is10&&<div style={{position:"absolute",left:0,right:0,top:y,height:2,background:"rgba(255,255,255,0.35)",zIndex:2}}/>}
                {is5&&<><div style={{position:"absolute",left:0,width:20,top:y,height:1,background:"rgba(255,255,255,0.25)",zIndex:2}}/><div style={{position:"absolute",right:0,width:20,top:y,height:1,background:"rgba(255,255,255,0.25)",zIndex:2}}/><div style={{position:"absolute",left:"50%",marginLeft:-6,width:12,top:y,height:1,background:"rgba(255,255,255,0.18)",zIndex:2}}/></>}
                {!is10&&!is5&&rd>=0&&rd<=50&&<div style={{position:"absolute",left:0,right:0,top:y,height:1,background:"rgba(255,255,255,0.08)"}}/>}
                {is10&&rd>0&&rd<=50&&<><div style={{position:"absolute",left:30,top:y-12,fontSize:20,fontWeight:800,color:"rgba(255,255,255,0.18)",fontFamily:"monospace",zIndex:2}}>{rd}</div><div style={{position:"absolute",right:30,top:y-12,fontSize:20,fontWeight:800,color:"rgba(255,255,255,0.18)",fontFamily:"monospace",zIndex:2}}>{rd}</div></>}
              </div>);
            })}
            {/* Hash marks ‚Äî small tick marks at each yard, at ~1/3 from each sideline */}
            {Array.from({length:60},(_,i)=>{
              const yo=(i-29.5)*1.0+effectiveCamY;const y=yS(yo);if(y<-10||y>FH+10)return null;
              const num=Math.round(game.bo+yo);if(num<1||num>99)return null;
              if(num%5===0)return null;
              const lHash=FW*0.295,rHash=FW*0.705;
              return(<Fragment key={`hm${i}`}>
                <div style={{position:"absolute",left:lHash-3,top:y,width:6,height:1,background:"rgba(255,255,255,0.12)",zIndex:2}}/>
                <div style={{position:"absolute",left:rHash-3,top:y,width:6,height:1,background:"rgba(255,255,255,0.12)",zIndex:2}}/>
              </Fragment>);
            })}
            {/* Goal posts ‚Äî narrow U shape at each goal line, viewed from above */}
            {(()=>{const y=yS(100-game.bo);if(y<-30||y>FH+30)return null;const cx=FW/2,w=40;return(<Fragment>
              <div style={{position:"absolute",left:cx-w/2,top:y-2,width:2,height:8,background:"#ddb830",zIndex:3,opacity:0.7}}/>
              <div style={{position:"absolute",left:cx+w/2-2,top:y-2,width:2,height:8,background:"#ddb830",zIndex:3,opacity:0.7}}/>
              <div style={{position:"absolute",left:cx-w/2,top:y-2,width:w,height:2,background:"#ddb830",zIndex:3,opacity:0.7}}/>
            </Fragment>);})()}
            {(()=>{const y=yS(-game.bo);if(y<-30||y>FH+30)return null;const cx=FW/2,w=40;return(<Fragment>
              <div style={{position:"absolute",left:cx-w/2,top:y-6,width:2,height:8,background:"#ddb830",zIndex:3,opacity:0.5}}/>
              <div style={{position:"absolute",left:cx+w/2-2,top:y-6,width:2,height:8,background:"#ddb830",zIndex:3,opacity:0.5}}/>
              <div style={{position:"absolute",left:cx-w/2,top:y-6,width:w,height:2,background:"#ddb830",zIndex:3,opacity:0.5}}/>
            </Fragment>);})()}
            {/* Midfield logo ‚Äî subtle TF at the 50 yard line */}
            {(()=>{const y50=yS(50-game.bo);if(y50<-30||y50>FH+30)return null;return <div style={{position:"absolute",left:"50%",top:y50-12,transform:"translateX(-50%)",fontSize:24,fontWeight:900,color:"rgba(255,255,255,0.06)",fontFamily:"'Segoe UI',Arial,sans-serif",letterSpacing:4,zIndex:1,pointerEvents:"none"}}>TF</div>;})()}
            {/* FIX 1 (15.0): Goal lines ‚Äî bold, distinct white */}
            {(()=>{const y=yS(100-game.bo);return(y>-10&&y<FH+10)?<div style={{position:"absolute",left:0,right:0,top:y-2,height:4,background:"rgba(255,255,255,0.85)",zIndex:5,boxShadow:"0 0 8px rgba(255,255,255,0.4)"}}/>:null;})()}
            {(()=>{const y=yS(-game.bo);return(y>-10&&y<FH+10)?<div style={{position:"absolute",left:0,right:0,top:y-1.5,height:3,background:"rgba(255,255,255,0.55)",zIndex:5}}/>:null;})()}
            {/* Line of scrimmage ‚Äî blue */}
            <div style={{position:"absolute",left:0,right:0,top:yS(0)-1,height:2,background:"rgba(74,158,255,0.55)",zIndex:5}}/>
            {/* First down marker ‚Äî yellow */}
            {game.dst<=30&&<div style={{position:"absolute",left:0,right:0,top:yS(game.dst)-1.5,height:3,background:"rgba(255,220,0,0.7)",zIndex:5,boxShadow:"0 0 6px rgba(255,220,0,0.4)"}}/>}
            {!["diff_select","menu","playcall","fourth"].includes(mode)&&<div style={{position:"absolute",bottom:6,left:"50%",transform:"translateX(-50%)",background:"rgba(0,0,0,0.75)",padding:"4px 14px",borderRadius:6,zIndex:30,display:"flex",gap:10,alignItems:"center"}}>
              <span style={{fontSize:18,fontWeight:900,color:"#fbbf24",fontFamily:"monospace"}}>{dlS} & {game.dst}</span>
              <span style={{fontSize:12,color:"#8a9ab0",fontWeight:600}}>{blS}</span>
            </div>}
            {renderGhosts()}
            {renderRunArrows()}
            {Object.entries(offP).map(([id,pos])=>renderPlayer(id,pos,"off"))}
            {Object.entries(displayDefPos).map(([id,pos])=>renderPlayer(id,pos,"def"))}
            {renderBcOverlay()}
            {/* On-field receiver openness labels + intended receiver highlight */}
            {["decision","pressure"].includes(mode)&&!isRun&&["wr1","wr2","te","rb"].map(id=>{
              const rp=offP[id];if(!rp)return null;
              const o=opn(id,offP,defPos,defSch);
              const px=xS(rp.x),py=yS(rp.y);
              if(py<-40||py>FH+40)return null;
              const col=o.col;
              const lab=o.lab;
              const isIntended=id===selPlay?.primary;
              return <Fragment key={`ol-${id}`}>
                {isIntended&&<div style={{position:"absolute",left:px-14,top:py-14,width:28,height:28,borderRadius:"50%",border:"3px solid #fbbf24",zIndex:14,pointerEvents:"none",boxShadow:"0 0 10px rgba(251,191,36,0.6), inset 0 0 6px rgba(251,191,36,0.3)"}}/>}
                {isIntended&&<div style={{position:"absolute",left:px-30,top:py+14,width:60,textAlign:"center",fontSize:7,fontWeight:800,color:"#fbbf24",zIndex:15,pointerEvents:"none",textShadow:"0 1px 3px rgba(0,0,0,0.9)",letterSpacing:0.5}}>INTENDED</div>}
                <div style={{position:"absolute",left:px-26,top:py-24,width:52,textAlign:"center",fontSize:8,fontWeight:800,color:col,zIndex:15,pointerEvents:"none",background:"rgba(0,0,0,0.6)",borderRadius:8,padding:"2px 4px",textShadow:"0 1px 2px rgba(0,0,0,0.9)"}}>{lab}</div>
              </Fragment>;
            })}
            {/* On-field OL status indicators */}
            {!["diff_select","menu","playcall","fourth"].includes(mode)&&!isRun&&OL_IDS.map(olId=>{
              const op=olPos[olId];if(!op)return null;
              const mu=Object.values(matchups).find(m=>m.olId===olId);if(!mu)return null;
              const px=xS(op.x),py=yS(op.y);
              if(py<-40||py>FH+40)return null;
              const col=mu.integrity>60?"#22c55e":mu.integrity>30?"#fbbf24":"#ef4444";
              return <div key={`ols-${olId}`} style={{position:"absolute",left:px-4,top:py+12,width:8,height:8,borderRadius:"50%",background:col,zIndex:15,pointerEvents:"none",boxShadow:`0 0 4px ${col}`}}/>;
            })}
            {/* POCKET BARS removed from field ‚Äî now in QB Decision header */}
            {/* Pocket warning overlay ‚Äî CHANGE 4: asymmetric collapse */}
            {!["diff_select","menu","playcall","fourth","result","touchdown","presnap"].includes(mode)&&!isRun&&pi<40&&(()=>{
              const colSide=pLR.left<pLR.right-15?"LEFT":pLR.right<pLR.left-15?"RIGHT":"BOTH SIDES";
              const arrow=colSide==="LEFT"?"‚Üê ":colSide==="RIGHT"?"‚Üí ":"";
              return <div style={{position:"absolute",top:yS(qbP.y)-40,left:"50%",transform:"translateX(-50%)",zIndex:30,pointerEvents:"none",textAlign:"center"}}>
                {pi<25?
                  <div style={{fontSize:14,fontWeight:900,color:"#ef4444",textShadow:"0 0 10px rgba(239,68,68,0.8)",animation:"pulse 0.8s ease-in-out infinite"}}>{arrow}THROW OR TUCK!{isPre(diff)&&<div style={{fontSize:9,fontWeight:400,color:"#f8a0a0",marginTop:2}}>Pocket broken {colSide==="BOTH SIDES"?"on both sides":"from the "+colSide.toLowerCase()} ‚Äî decide now!</div>}</div>:
                  <div style={{fontSize:12,fontWeight:800,color:"#fbbf24",textShadow:"0 0 8px rgba(251,191,36,0.6)"}}>{arrow}POCKET COLLAPSING{isPre(diff)&&<div style={{fontSize:9,fontWeight:400,color:"#e0c060",marginTop:2}}>Pressure from the {colSide.toLowerCase()} ‚Äî decide soon</div>}</div>
                }
              </div>;
            })()}
            {renderBall()}
            {contactFlash&&(()=>{const cx=xS(contactFlash.x),cy=yS(contactFlash.y);return cy>-40&&cy<FH+40?<div style={{position:"absolute",left:cx-50,top:cy-45,width:100,textAlign:"center",zIndex:35,pointerEvents:"none",background:"rgba(0,0,0,0.7)",padding:"4px 8px",borderRadius:6,border:"1px solid rgba(251,191,36,0.5)"}}>
              <div style={{fontSize:12,fontWeight:800,color:"#fff"}}>{contactFlash.label} ‚Äî {contactFlash.brk}%</div>
              <div style={{fontSize:10,color:contactFlash.fum<3?"#22c55e":contactFlash.fum<8?"#fbbf24":"#ef4444"}}>Fumble: 1 in {contactFlash.fum>0?Math.round(100/contactFlash.fum):"‚àû"}</div>
            </div>:null;})()}
            <Fireworks show={showTD}/>
            {/* FIX 7 (15.0): Broadcast-style pressure/open alerts */}
            {fieldAlert&&<div key={fieldAlert.key} style={{position:"absolute",top:"50%",left:"50%",transform:"translate(-50%,-50%)",zIndex:36,pointerEvents:"none",animation:"alertFade 2s ease-out forwards"}}>
              <div style={{fontSize:28,fontWeight:900,color:fieldAlert.color,textShadow:`0 0 20px ${fieldAlert.color}, 0 2px 8px rgba(0,0,0,0.8)`,letterSpacing:3,textAlign:"center",fontFamily:"'Segoe UI','Helvetica Neue',Arial,sans-serif",whiteSpace:"nowrap"}}>{fieldAlert.text}</div>
            </div>}
            {defSch&&!["diff_select","menu","playcall","fourth"].includes(mode)&&(
              <div style={{position:"absolute",top:5,left:"50%",transform:"translateX(-50%)",background:"rgba(200,40,40,0.75)",padding:"2px 10px",borderRadius:4,fontSize:10,fontWeight:700,color:"#fff",zIndex:30}}>
                {defSch.name}{lookDir&&<span style={{marginLeft:6,color:"#fbbf24"}}>üëÄ{lookDir==="left"?"‚Üê":"‚Üí"}</span>}
              </div>
            )}
            {!["diff_select","menu","playcall","fourth"].includes(mode)&&Object.entries(matchups).length>0&&(
              <div style={{position:"absolute",top:5,left:8,display:"flex",gap:3,zIndex:30}}>
                {Object.entries(OL_BLK).map(([dl,ol])=>{
                  const mu=matchups[dl];if(!mu)return null;
                  const c=mu.integrity>60?"#22c55e":mu.integrity>30?"#fbbf24":"#ef4444";
                  return<div key={dl} title={`${ol.toUpperCase()} vs ${dl.toUpperCase()}: ${Math.round(mu.integrity)}%`} style={{width:8,height:8,borderRadius:"50%",background:c,border:"1px solid rgba(0,0,0,0.3)"}}/>;
                })}
              </div>
            )}
            {!["diff_select","menu","playcall","result","touchdown","fourth","presnap","contact"].includes(mode)&&isRun&&(
              <div style={{position:"absolute",bottom:5,left:"50%",transform:"translateX(-50%)",display:"flex",gap:8,alignItems:"center",background:"rgba(0,0,0,0.6)",padding:"3px 12px",borderRadius:4,fontSize:10,color:"#aaa",zIndex:30}}>
                <span>{isCatch?`YAC ${runAct}/${MAX_YAC}`:`Run #${runAct}`}</span><span style={{color:"#333"}}>|</span><span>Nearest: {nd?`${nd.p?.lab||"?"} ${nd.d.toFixed(1)}yds`:"‚Äî"}</span>
              </div>
            )}
            {ballSt==="air"&&ballAn&&<div style={{position:"absolute",top:FH-28,left:"50%",transform:"translateX(-50%)",background:"rgba(251,191,36,0.85)",padding:"2px 12px",borderRadius:4,fontSize:11,fontWeight:800,color:"#000",zIndex:30}}>IN THE AIR!</div>}
            {mode==="touchdown"&&(
              <div style={{position:"absolute",inset:0,background:"rgba(0,0,0,0.65)",display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",zIndex:40}}>
                <div style={{fontSize:64,animation:"tdBounce 0.6s ease-out forwards",marginBottom:8}}>üèà</div>
                <div style={{fontSize:42,fontWeight:900,color:"#fbbf24",animation:"tdGlow 1.5s ease-in-out infinite",letterSpacing:4}}>TOUCHDOWN!</div>
                <div style={{fontSize:16,color:"#fff",marginTop:8,fontWeight:600}}>+7 points</div>
              </div>
            )}
            {/* DAN & KIKI COMMENTARY ‚Äî TV broadcast style */}
            {(mode==="result"||mode==="touchdown")&&commentary&&(
              <div style={{position:"absolute",top:8,left:8,right:8,zIndex:38}}>
                {/* Header badge */}
                <div style={{display:"inline-block",background:"linear-gradient(135deg,#0a1628,#162a4a)",padding:"3px 12px",borderRadius:"3px 3px 0 0",borderBottom:"2px solid #fbbf24",marginBottom:0}}>
                  <span style={{fontSize:9,fontWeight:800,color:"#fbbf24",letterSpacing:2,fontFamily:"'Segoe UI','Helvetica Neue',Arial,sans-serif"}}>üéôÔ∏è ANNOUNCER'S BOOTH</span>
                </div>
                {/* Dan's line ‚Äî blue accent stripe */}
                {commentary.dan&&<div style={{display:"flex",marginBottom:2}}>
                  <div style={{width:4,flexShrink:0,background:"#4a9eff",borderRadius:"0 0 0 2px"}}/>
                  <div style={{flex:1,background:"rgba(10,22,40,0.92)",padding:"6px 12px",backdropFilter:"blur(4px)"}}>
                    <span style={{fontSize:10,fontWeight:700,color:"#4a9eff",marginRight:6,fontFamily:"'Segoe UI','Helvetica Neue',Arial,sans-serif"}}>DAN</span>
                    <span style={{fontSize:13,color:"#e8edf4",fontWeight:600,lineHeight:1.5,fontFamily:"'Segoe UI','Helvetica Neue',Arial,sans-serif"}}>{commentary.dan}</span>
                  </div>
                </div>}
                {/* Kiki's line ‚Äî gold accent stripe */}
                {commentary.kiki&&<div style={{display:"flex",marginBottom:2}}>
                  <div style={{width:4,flexShrink:0,background:"#f5a623",borderRadius:"0 0 0 2px"}}/>
                  <div style={{flex:1,background:"rgba(10,22,40,0.92)",padding:"6px 12px",backdropFilter:"blur(4px)",borderRadius:"0 0 4px 0"}}>
                    <span style={{fontSize:10,fontWeight:700,color:"#f5a623",marginRight:6,fontFamily:"'Segoe UI','Helvetica Neue',Arial,sans-serif"}}>KIKI</span>
                    <span style={{fontSize:13,color:"#ffecc4",fontWeight:600,lineHeight:1.5,fontStyle:"italic",fontFamily:"'Segoe UI','Helvetica Neue',Arial,sans-serif"}}>{commentary.kiki}</span>
                  </div>
                </div>}
                {/* FIX 2 (15.1): DISMISS button ‚Äî normal size, right-aligned */}
                <div style={{textAlign:"right",marginTop:2}}><button onClick={()=>{if(commentaryTimer.current)clearTimeout(commentaryTimer.current);setCommentary(null);}} style={{background:"rgba(10,22,40,0.92)",border:"1px solid #2a3a50",borderRadius:3,color:"#6a7a90",fontSize:9,fontWeight:700,padding:"3px 12px",cursor:"pointer",letterSpacing:1}}>DISMISS</button></div>
              </div>
            )}
          </div>

          {/* COACH + NARRATIVE ‚Äî compact single lines */}
          {coach&&!["result","touchdown"].includes(mode)&&<div style={{maxWidth:FW,margin:"2px auto 0",padding:"3px 10px",background:"#101520",borderRadius:4,borderLeft:`3px solid ${coachType==="A"?"#4a9eff":"#22c55e"}`,fontSize:10,color:"#8ab4e0",lineHeight:1.3,overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}}>üéß {coach}</div>}
          {narr&&<div style={{maxWidth:FW,margin:"2px auto 0",padding:"3px 10px",background:"#12181f",borderRadius:4,borderLeft:"3px solid #fbbf24",fontSize:11,color:"#e0d8c0",fontStyle:"italic",overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}}>{narr}</div>}

          {/* PRACTICE OVERLAY ‚Äî compact, collapses completely on GOT IT */}
          {practiceOverlay&&diff==="practice"&&(
            <div style={{maxWidth:FW,margin:"4px auto",padding:"8px 12px",background:"rgba(10,15,30,0.97)",borderRadius:6,border:"1px solid #4a9eff",zIndex:100,position:"relative"}}>
              <div style={{fontSize:11,color:"#d0dce8",lineHeight:1.5,marginBottom:6}}><span style={{color:"#d4a060",fontWeight:700}}>üìã </span>{practiceOverlay}</div>
              <button onClick={()=>setPracticeOverlay(null)} style={{...btn,width:"100%",padding:6,background:"#4a9eff",color:"#000",fontSize:12,fontWeight:800,borderRadius:4}}>GOT IT</button>
            </div>
          )}

          {/* CONTROLS */}
          <div style={{maxWidth:FW,margin:"2px auto 0"}}>

            {mode==="p2_defense"&&(
              <div style={{transform:"rotate(180deg)",padding:16,background:"#0a0e1a",borderRadius:8,border:"2px solid #a855f7",textAlign:"center"}}>
                <div style={{fontSize:16,fontWeight:800,color:"#a855f7",letterSpacing:2,marginBottom:4}}>DEFENSE ‚Äî PICK YOUR FORMATION</div>
                <div style={{fontSize:11,color:"#8a9ab0",marginBottom:12}}>P{offensePlayer===1?2:1} ‚Äî choose wisely. P{offensePlayer} has called their play.</div>
                <div style={{display:"flex",flexDirection:"column",gap:8,maxWidth:420,margin:"0 auto"}}>
                  {Object.entries(DEFS).map(([key,d])=>(
                    <button key={key} onClick={()=>p2PickDef(key)} style={{...btn,padding:"12px 16px",background:"#0e1520",border:"1px solid #a855f744",color:"#d0dce8",textAlign:"left"}}>
                      <div style={{fontSize:16,fontWeight:800,color:"#a855f7"}}>{d.name}</div>
                      <div style={{fontSize:13,color:"#8a9ab0",marginTop:2}}>{d.desc}</div>
                    </button>
                  ))}
                </div>
              </div>
            )}

            {mode==="menu"&&!pCat&&(
              <div>
                <div style={{fontSize:11,color:"#5a7090",marginBottom:6,fontWeight:700,letterSpacing:1}}>CALL YOUR PLAY</div>
                <div style={{display:"flex",gap:8}}>
                  {[{cat:"run",icon:"üèÉ",label:"RUN",desc:[
            "Hand off and run",
          ],col:"#f97316"},
                    {cat:"pass",icon:"üéØ",label:"PASS",desc:[
            "Throw to a receiver",
          ],col:"#4a9eff"},
                    {cat:"trick",icon:"üé™",label:"TRICK",desc:[
            "Deception plays",
          ],col:"#a855f7"},
                  ].map(c=>(<button key={c.cat} onClick={()=>{setPCat(c.cat);setMode("playcall");}} style={{...btn,flex:1,padding:"8px 8px",background:"#0e1520",border:`2px solid ${c.col}44`,color:c.col,fontSize:14,fontWeight:800}}>
                    <div>{c.icon} {c.label}</div><div style={{fontSize:9,color:"#5a7090",fontWeight:400,marginTop:2}}>{Array.isArray(c.desc)?c.desc.join(" "):c.desc}</div>
                  </button>))}
                </div>
                {game.dn===4&&<button onClick={()=>setMode("fourth")} style={{...btn,marginTop:8,width:"100%",padding:10,background:"#1a1510",border:"1px solid #4a3010",color:"#f97316",fontSize:13,fontWeight:700}}>ü¶µ KICK OPTIONS</button>}
              </div>
            )}

            {mode==="playcall"&&pCat&&(
              <div>
                <div style={{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:6}}>
                  <div style={{fontSize:11,color:"#5a7090",fontWeight:700}}>{pCat.toUpperCase()} PLAYS</div>
                  <button onClick={()=>{setPCat(null);setMode("menu");setSelPlay(null);setShowGhost(false);}} style={{...btn,padding:"3px 10px",background:"#1a1520",border:"1px solid #2a2540",color:"#8a8ab0",fontSize:10}}>‚Üê Back</button>
                </div>
                <div style={{display:"flex",flexDirection:"column",gap:4}}>
                  {pcStaples.length>0&&<>
                    {pCat==="run"&&<div style={{fontSize:9,color:"#4a6a90",fontWeight:700,letterSpacing:1,marginTop:2}}>YOUR PLAYBOOK</div>}
                    {pcStaples.map(p=><button key={p.name} onClick={()=>selectPlay(p)} onDoubleClick={()=>quickSnap(p)} style={{...btn,background:selPlay?.name===p.name?"#162a4a":"#0e1520",border:selPlay?.name===p.name?"2px solid #3a7acc":"1px solid #1a2540",padding:selPlay?.name===p.name?"8px 12px":"6px 12px",textAlign:"left",color:"#d0dce8",width:"100%"}}>
                      <div style={{display:"flex",alignItems:"center",gap:6}}>
                        <span style={{fontSize:14}}>{p.icon}</span>
                        <span style={{fontSize:13,fontWeight:700}}>{p.name}</span>
                        {selPlay?.name!==p.name&&<span style={{fontSize:10,color:"#6a7a90",flex:1,overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}}> ‚Äî {p.brief}</span>}
                      </div>
                      {isPre(diff)&&p.tooltip&&selPlay?.name!==p.name&&<div style={{fontSize:9,color:"#5a7a90",marginTop:2,paddingLeft:20}}>{p.tooltip}</div>}
                      {selPlay?.name===p.name&&<div style={{marginTop:4}}>
                        <div style={{fontSize:10,color:"#8a9ab0",lineHeight:1.4,marginBottom:6}}>{p.brief}</div>
                        <div style={{fontSize:10,color:"#6a7a90",marginBottom:6}}>{Array.isArray(p.desc)?p.desc.map((line,i)=><div key={i} style={{display:"flex",gap:6,marginBottom:3,lineHeight:1.4}}><span style={{color:"#3a5570",flexShrink:0}}>‚Ä¢</span><span>{line}</span></div>):<div style={{lineHeight:1.4}}>{p.desc}</div>}</div>
                        <div style={{display:"flex",gap:6,flexWrap:"wrap"}}>
                          {p.strong&&<span style={{fontSize:9,padding:"2px 6px",borderRadius:3,background:"#22c55e22",color:"#22c55e",border:"1px solid #22c55e44"}}>‚úì vs {p.strong}: {p.strongWhy}</span>}
                          {p.weak&&<span style={{fontSize:9,padding:"2px 6px",borderRadius:3,background:"#ef444422",color:"#ef4444",border:"1px solid #ef444444"}}>‚úó vs {p.weak}: {p.weakWhy}</span>}
                        </div>
                      </div>}
                    </button>)}
                  </>}
                  {pcSituational.length>0&&<>
                    <div style={{fontSize:9,color:"#4a6a90",fontWeight:700,letterSpacing:1,marginTop:6,borderTop:"1px solid #1a2540",paddingTop:6}}>SITUATIONAL</div>
                    {pcSituational.map(p=><button key={p.name} onClick={()=>selectPlay(p)} onDoubleClick={()=>quickSnap(p)} style={{...btn,background:selPlay?.name===p.name?"#162a4a":"#0e1520",border:selPlay?.name===p.name?"2px solid #3a7acc":"1px solid #1a2540",padding:selPlay?.name===p.name?"8px 12px":"6px 12px",textAlign:"left",color:"#d0dce8",width:"100%"}}>
                      <div style={{display:"flex",alignItems:"center",gap:6}}>
                        <span style={{fontSize:14}}>{p.icon}</span>
                        <span style={{fontSize:13,fontWeight:700}}>{p.name}</span>
                        {selPlay?.name!==p.name&&<span style={{fontSize:10,color:"#6a7a90",flex:1,overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}}> ‚Äî {p.brief}</span>}
                      </div>
                      {isPre(diff)&&p.tooltip&&selPlay?.name!==p.name&&<div style={{fontSize:9,color:"#5a7a90",marginTop:2,paddingLeft:20}}>{p.tooltip}</div>}
                      {selPlay?.name===p.name&&<div style={{marginTop:4}}>
                        <div style={{fontSize:10,color:"#8a9ab0",lineHeight:1.4,marginBottom:6}}>{p.brief}</div>
                        <div style={{fontSize:10,color:"#6a7a90",marginBottom:6}}>{Array.isArray(p.desc)?p.desc.map((line,i)=><div key={i} style={{display:"flex",gap:6,marginBottom:3,lineHeight:1.4}}><span style={{color:"#3a5570",flexShrink:0}}>‚Ä¢</span><span>{line}</span></div>):<div style={{lineHeight:1.4}}>{p.desc}</div>}</div>
                        <div style={{display:"flex",gap:6,flexWrap:"wrap"}}>
                          {p.strong&&<span style={{fontSize:9,padding:"2px 6px",borderRadius:3,background:"#22c55e22",color:"#22c55e",border:"1px solid #22c55e44"}}>‚úì vs {p.strong}: {p.strongWhy}</span>}
                          {p.weak&&<span style={{fontSize:9,padding:"2px 6px",borderRadius:3,background:"#ef444422",color:"#ef4444",border:"1px solid #ef444444"}}>‚úó vs {p.weak}: {p.weakWhy}</span>}
                        </div>
                      </div>}
                    </button>)}
                  </>}
                  {pcSpecial.length>0&&<>
                    <div style={{fontSize:9,color:"#4a6a90",fontWeight:700,letterSpacing:1,marginTop:6,borderTop:"1px solid #1a2540",paddingTop:6}}>SPECIALTY</div>
                    {pcSpecial.map(p=><button key={p.name} onClick={()=>selectPlay(p)} onDoubleClick={()=>quickSnap(p)} style={{...btn,background:selPlay?.name===p.name?"#162a4a":"#0e1520",border:selPlay?.name===p.name?"2px solid #3a7acc":"1px solid #1a2540",padding:selPlay?.name===p.name?"8px 12px":"6px 12px",textAlign:"left",color:"#d0dce8",width:"100%"}}>
                      <div style={{display:"flex",alignItems:"center",gap:6}}>
                        <span style={{fontSize:14}}>{p.icon}</span>
                        <span style={{fontSize:13,fontWeight:700}}>{p.name}</span>
                        {selPlay?.name!==p.name&&<span style={{fontSize:10,color:"#6a7a90",flex:1,overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}}> ‚Äî {p.brief}</span>}
                      </div>
                      {isPre(diff)&&p.tooltip&&selPlay?.name!==p.name&&<div style={{fontSize:9,color:"#5a7a90",marginTop:2,paddingLeft:20}}>{p.tooltip}</div>}
                      {selPlay?.name===p.name&&<div style={{marginTop:4}}>
                        <div style={{fontSize:10,color:"#8a9ab0",lineHeight:1.4,marginBottom:6}}>{p.brief}</div>
                        <div style={{fontSize:10,color:"#6a7a90",marginBottom:6}}>{Array.isArray(p.desc)?p.desc.map((line,i)=><div key={i} style={{display:"flex",gap:6,marginBottom:3,lineHeight:1.4}}><span style={{color:"#3a5570",flexShrink:0}}>‚Ä¢</span><span>{line}</span></div>):<div style={{lineHeight:1.4}}>{p.desc}</div>}</div>
                        <div style={{display:"flex",gap:6,flexWrap:"wrap"}}>
                          {p.strong&&<span style={{fontSize:9,padding:"2px 6px",borderRadius:3,background:"#22c55e22",color:"#22c55e",border:"1px solid #22c55e44"}}>‚úì vs {p.strong}: {p.strongWhy}</span>}
                          {p.weak&&<span style={{fontSize:9,padding:"2px 6px",borderRadius:3,background:"#ef444422",color:"#ef4444",border:"1px solid #ef444444"}}>‚úó vs {p.weak}: {p.weakWhy}</span>}
                        </div>
                      </div>}
                    </button>)}
                  </>}
                </div>
                {selPlay&&<button onClick={goPresnap} style={{...btn,marginTop:8,width:"100%",padding:11,background:"linear-gradient(135deg,#16a34a,#15803d)",color:"#fff",fontSize:15,fontWeight:800,letterSpacing:2}}>LINE UP ‚Üí</button>}
              </div>
            )}

            {mode==="presnap"&&(
              <div style={{background:"#10151f",borderRadius:8,padding:12,border:"1px solid #2a3550"}}>
                <div style={{fontSize:13,color:"#f97316",fontWeight:700,marginBottom:4}}>PRE-SNAP READ</div>
                <div style={{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:4}}>
                  <div style={{fontSize:11,color:"#8a9ab0"}}>Your play: <span style={{color:"#4a9eff",fontWeight:700}}>{selPlay?.name}</span></div>
                  {defSch&&selPlay&&(()=>{
                    const mxR=MX[selPlay.name]?.[defSch.key]||0;
                    return <span style={{fontSize:10,fontWeight:700,color:mxColor(mxR),background:`${mxColor(mxR)}22`,padding:"2px 8px",borderRadius:4}}>{mxLabel(mxR)} MATCHUP</span>;
                  })()}
                </div>
                <div style={{fontSize:11,color:"#8a9ab0",marginBottom:2}}>Defense: <span style={{color:"#ef4444",fontWeight:700}}>{defSch?.name}</span></div>
                <div style={{fontSize:10,color:"#6a7a90",marginBottom:10,lineHeight:1.4}}>{defSch?.desc&&Array.isArray(defSch.desc)?defSch.desc.map((line,i)=><div key={i} style={{display:"flex",gap:5,marginBottom:2,lineHeight:1.4}}><span style={{color:"#3a5570",flexShrink:0}}>‚Ä¢</span><span>{line}</span></div>):<div style={{lineHeight:1.4}}>{defSch?.desc}</div>}</div>
                {(()=>{
                  const mxR=selPlay&&defSch?MX[selPlay.name]?.[defSch.key]||0:0;
                  if(diff==="playoffs"&&mxR<=-1)return(<div style={{fontSize:10,color:"#fbbf24",marginBottom:8,padding:"6px 8px",background:"#1a1510",borderRadius:4,border:"1px solid #4a3a10",lineHeight:1.4}}>‚ö†Ô∏è Risky matchup.</div>);
                  if(diff==="playoffs")return null;
                  if(diff==="practice")return null;
                  if(diff==="regular"&&mxR<=-2){const suggs=findSuggestions(defSch?.key);return(<div style={{fontSize:10,color:"#ef4444",marginBottom:8,padding:"6px 8px",background:"#1a0a0a",borderRadius:4,border:"1px solid #5a2020",lineHeight:1.5}}>
                    <div>‚ö†Ô∏è Tough call against {defSch?.name}.</div>
                    {suggs.length>0&&<div style={{marginTop:4}}>{suggs.map((s,i)=><span key={i}>{i>0?" or ":"Consider "}<span onClick={()=>{selectPlay(s);setRoutes(getRoutes(s));goPresnapFor(s);}} style={{color:"#4a9eff",cursor:"pointer",fontWeight:700,textDecoration:"underline"}}>{s.name}</span></span>)}.</div>}
                  </div>);}
                  if(diff==="regular"&&mxR<=-1){const suggs=findSuggestions(defSch?.key);return(<div style={{fontSize:10,color:"#fbbf24",marginBottom:8,padding:"6px 8px",background:"#1a1510",borderRadius:4,border:"1px solid #4a3a10",lineHeight:1.5}}>
                    <div>‚ö†Ô∏è Bad matchup.</div>
                    {suggs.length>0&&<div style={{marginTop:4}}>{suggs.map((s,i)=><span key={i}>{i>0?" or ":"Try "}<span onClick={()=>{selectPlay(s);setRoutes(getRoutes(s));goPresnapFor(s);}} style={{color:"#4a9eff",cursor:"pointer",fontWeight:700,textDecoration:"underline"}}>{s.name}</span></span>)}.</div>}
                  </div>);}
                  if(diff==="regular")return null;
                  if(mxR>=2)return(<div style={{fontSize:10,color:"#22c55e",marginBottom:8,padding:"6px 8px",background:"#0a1810",borderRadius:4,border:"1px solid #1a4a1a",lineHeight:1.4}}>Great call! Perfect play against {defSch?.name}.</div>);
                  if(mxR>=1)return(<div style={{fontSize:10,color:"#4ade80",marginBottom:8,padding:"6px 8px",background:"#0a1810",borderRadius:4,border:"1px solid #1a3a1a",lineHeight:1.4}}>Good call. {defSch?.name} is vulnerable to this.</div>);
                  if(mxR===0)return(<div style={{fontSize:10,color:"#8a9ab0",marginBottom:8,padding:"6px 8px",background:"#0e1520",borderRadius:4,border:"1px solid #1a2540",lineHeight:1.4}}>Decent look. Trust your reads.</div>);
                  const suggs=findSuggestions(defSch?.key);
                  const severity=mxR<=-2?"BAD":"risky";
                  const prefix=mxR<=-2?`This is a BAD call against ${defSch?.name}. ${selPlay?.weakWhy||""}`:`Careful ‚Äî they're in ${defSch?.name}. ${selPlay?.weakWhy||""}`;
                  return(<div style={{fontSize:10,color:mxR<=-2?"#ef4444":"#fbbf24",marginBottom:8,padding:"6px 8px",background:mxR<=-2?"#1a0a0a":"#1a1510",borderRadius:4,border:`1px solid ${mxR<=-2?"#5a2020":"#4a3a10"}`,lineHeight:1.5}}>
                    <div>‚ö†Ô∏è {prefix}</div>
                    {suggs.length>0&&<div style={{marginTop:4}}>{suggs.map((s,i)=><span key={i}>{i>0?" Or ":"Try "}<span onClick={()=>{selectPlay(s);setRoutes(getRoutes(s));goPresnapFor(s);}} style={{color:"#4a9eff",cursor:"pointer",fontWeight:700,textDecoration:"underline"}}>{s.name}</span> ‚Äî {s.strongWhy}</span>)}</div>}
                  </div>);
                })()}
                <div style={{display:"flex",gap:8}}>
                  <button onClick={snap} style={{...btn,flex:2,padding:12,background:"linear-gradient(135deg,#16a34a,#15803d)",color:"#fff",fontSize:15,fontWeight:800,letterSpacing:2}}>‚ö° SNAP</button>
                  <button onClick={()=>{setMode("playcall");setShowGhost(true);}} style={{...btn,flex:1,padding:12,background:"#1a1510",border:"1px solid #4a3010",color:"#f97316",fontSize:13,fontWeight:700}}>üîä AUDIBLE</button>
                </div>
              </div>
            )}

            {mode==="rpo"&&rpoData&&(()=>{
              const isOpen=rpoData.scenario==="gap_open";
              const sLabel=isPre(diff)?(rpoData.scenario==="gap_open"?"THERE'S A HOLE!":rpoData.scenario==="lb_filled"?"DEFENDER CLOSED THE LANE":"NO ROOM OUTSIDE"):(rpoData.scenario==="gap_open"?"GAP IS OPEN":rpoData.scenario==="lb_filled"?"LB FILLED THE GAP":"EDGE SEALED");
              const sColor=isOpen?"#22c55e":"#ef4444";
              const hoPct=isOpen?rnd(75,88):rnd(18,30);
              const qkPct=isOpen?rnd(50,62):rnd(58,70);
              const qpPct=isOpen?rnd(82,90):rnd(85,94);
              return(<div style={{background:"#10151f",borderRadius:8,padding:12,border:`2px solid ${sColor}`}}>
                <div style={{fontSize:14,fontWeight:800,color:"#f97316",marginBottom:2}}>üèà POST-SNAP READ</div>
                <div style={{fontSize:13,fontWeight:800,color:sColor,marginBottom:6}}>{sLabel}</div>
                <div style={{display:"grid",gridTemplateColumns:"1fr 1fr 1fr",gap:6}}>
                  <button onClick={()=>doRPO(isOpen?"handoff":"handoff_bad")} style={{...btn,padding:"10px 6px",background:isOpen?"#0a1810":"#1a0a0a",border:`1px solid ${isOpen?"#22c55e":"#5a2020"}`,color:isOpen?"#22c55e":"#ef4444",textAlign:"center"}}>
                    <div style={{fontSize:12,fontWeight:800}}>{isPre(diff)?(isOpen?"üèà Hand Off (run the play)":"üèà Hand Off"):(isOpen?"üèà Hand Off":"üèà Hand Off")}</div>
                    <div style={{fontSize:9,color:isOpen?"#4a8a50":"#8a4040",marginTop:2}}>{isOpen?"Run as planned":"Into traffic"}</div>
                    <div style={{fontSize:11,fontWeight:700,marginTop:4,color:isOpen?"#4ade80":"#f87171",background:isOpen?"#4ade8018":"#f8717118",padding:"2px 6px",borderRadius:3}}>{hoPct}%</div>
                  </button>
                  <button onClick={()=>doRPO("qb_keep")} style={{...btn,padding:"10px 6px",background:"#0a1020",border:"1px solid #2a4a6a",color:"#4a9eff",textAlign:"center"}}>
                    <div style={{fontSize:12,fontWeight:800}}>üèÉ QB Keep</div>
                    <div style={{fontSize:9,color:"#3a6a90",marginTop:2}}>Fake & run</div>
                    <div style={{fontSize:11,fontWeight:700,marginTop:4,color:qkPct>50?"#4ade80":"#fbbf24",background:qkPct>50?"#4ade8018":"#fbbf2418",padding:"2px 6px",borderRadius:3}}>{qkPct}%</div>
                  </button>
                  {(()=>{
                    const sc=rpoData.scenario;
                    const qpDesc=sc==="edge_sealed"?"WR wide open, 8-15yds":sc==="lb_filled"?"Contested, 5-8yds":"Bubble, 3-5yds";
                    const qpCol=sc==="edge_sealed"?"#22c55e":sc==="lb_filled"?"#fbbf24":"#a0a0ff";
                    const qpBg=sc==="edge_sealed"?"#0a1810":sc==="lb_filled"?"#1a1510":"#101020";
                    const qpBorder=sc==="edge_sealed"?"#22c55e":sc==="lb_filled"?"#4a3a10":"#3a3a6a";
                    return <button onClick={()=>doRPO("quick_pass")} style={{...btn,padding:"10px 6px",background:qpBg,border:`1px solid ${qpBorder}`,color:qpCol,textAlign:"center"}}>
                      <div style={{fontSize:12,fontWeight:800}}>üì° Quick Pass</div>
                      <div style={{fontSize:9,color:qpCol+"aa",marginTop:2}}>{qpDesc}</div>
                      <div style={{fontSize:11,fontWeight:700,marginTop:4,color:sc==="edge_sealed"?"#4ade80":"#4ade80",background:"#4ade8018",padding:"2px 6px",borderRadius:3}}>{qpPct}%</div>
                    </button>;
                  })()}
                </div>
              </div>);
            })()}

            {mode==="fourth"&&(
              <div style={{background:"#10151f",borderRadius:8,padding:14,border:"2px solid #f97316"}}>
                <div style={{fontSize:15,fontWeight:800,color:"#f97316",marginBottom:8}}>4TH DOWN</div>
                <div style={{display:"flex",gap:8}}>
                  <button onClick={()=>doFourth("punt")} style={{...btn,flex:1,padding:"12px 8px",background:"#0e1520",border:"1px solid #1a2540",color:"#8ab4e0",fontSize:13,fontWeight:700}}>üì¢ Punt</button>
                  <button onClick={()=>doFourth("fg")} style={{...btn,flex:1,padding:"12px 8px",background:fgD<=50?"#0e1a10":"#0e1520",border:`1px solid ${fgD<=50?"#2a5a2a":"#1a2540"}`,color:fgD<=50?"#4ade80":"#8ab4e0",fontSize:13,fontWeight:700}}>ü•Ö FG ({fgD}yds)</button>
                  <button onClick={()=>doFourth("goforit")} style={{...btn,flex:1,padding:"12px 8px",background:"#1a1008",border:"1px solid #4a2a08",color:"#f97316",fontSize:13,fontWeight:700}}>üí™ Go For It</button>
                </div>
              </div>
            )}

            {(mode==="snapping"||mode==="animating")&&<div style={{textAlign:"center",padding:12,color:"#fbbf24",fontSize:13,fontWeight:700}}>‚è± {mode==="snapping"?"Ball snapped...":"Play developing..."}</div>}

            {mode==="decision"&&(
              <div>
                <div style={{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:3}}>
                  <div style={{fontSize:11,color:"#fbbf24",fontWeight:700}}>üèà QB DECISION</div>
                  <div style={{display:"flex",flexDirection:"column",alignItems:"center",gap:1}}>
                    {Object.keys(matchups).length>0&&(()=>{
                      const lPct=cl(pLR.left,0,100)/100;
                      const rPct=cl(pLR.right,0,100)/100;
                      const barCol=p=>p>0.6?"#22c55e":p>0.3?"#fbbf24":"#ef4444";
                      return <div style={{display:"flex",flexDirection:"column",alignItems:"center",gap:1}}>
                        <span style={{fontSize:7,fontWeight:700,color:"#6a7a90",letterSpacing:1}}>POCKET INTEGRITY</span>
                        <div style={{display:"flex",alignItems:"center",gap:4}}>
                          <span style={{fontSize:7,fontWeight:700,color:"#8a9ab0",width:22,textAlign:"right"}}>Left</span>
                          <div style={{width:40,height:6,background:"#1a2540",borderRadius:3,overflow:"hidden"}}><div style={{width:40*lPct,height:6,background:barCol(lPct),borderRadius:3,transition:"width 0.3s ease, background 0.3s ease"}}/></div>
                          <span style={{fontSize:7,fontWeight:700,color:"#8a9ab0",width:24,textAlign:"right"}}>Right</span>
                          <div style={{width:40,height:6,background:"#1a2540",borderRadius:3,overflow:"hidden"}}><div style={{width:40*rPct,height:6,background:barCol(rPct),borderRadius:3,transition:"width 0.3s ease, background 0.3s ease"}}/></div>
                        </div>
                      </div>;
                    })()}
                    <div style={{fontSize:10,color:"#5a7090"}}>Phase {phase}</div>
                  </div>
                </div>
                {(()=>{
                  const allActs=getQBActions();
                  const throws=allActs.filter(a=>a.cat==="throw");
                  const scrambleLane=allActs.find(a=>a.type==="scramble_lane");
                  // BUG 7: Find best 1-2 throws for Practice/Preseason highlighting
                  const sorted=[...throws].sort((a,b)=>(b.cp-b.ip)-(a.cp-a.ip));
                  const bestIds=isPre(diff)?sorted.slice(0,2).map(a=>a.target):[];
                  // FIX 3 (14.7): Primary receiver ‚Äî the play's intended target
                  const primaryId=selPlay?.primary||null;
                  const primaryOp=primaryId?opn(primaryId,offP,defPos,defSch):null;
                  const primaryCovered=primaryOp&&primaryOp.o<=0;
                  // Coach explanation based on defense
                  const defKey=defSch?.key;
                  const whyMap={
                    cover2:{te:"Cover 2 ‚Äî both safeties dropped deep to protect against long passes, so the middle of the field is open. Look for your tight end there.",rb:"Cover 2 ‚Äî safeties are playing deep, leaving short passes underneath wide open. Quick throw to the running back.",wr1:"Cover 2 ‚Äî safeties are deep protecting the long ball. Short routes underneath have room.",wr2:"Cover 2 ‚Äî safeties are deep protecting the long ball. Short routes underneath have room."},
                    base43:{wr1:"4-3 Base ‚Äî balanced defense, four linemen and three linebackers. The outside receivers have room to work.",wr2:"4-3 Base ‚Äî balanced defense, four linemen and three linebackers. The outside receivers have room to work.",te:"4-3 Base ‚Äî linebackers are spread out covering the run, so the tight end has a seam up the middle.",rb:"4-3 Base ‚Äî defense is playing honest, quick pass to the running back in the flat could work."},
                    nickel:{te:"Nickel ‚Äî extra defensive back instead of a linebacker, locking down the wide receivers. But the tight end has space in the middle.",rb:"Nickel ‚Äî extra DB is covering the wide receivers tight. Dump it to the running back underneath.",wr1:"Nickel ‚Äî extra DB tightens coverage on receivers, but this one found a window.",wr2:"Nickel ‚Äî extra DB tightens coverage on receivers, but this one found a window."},
                    blitz:{wr1:"Blitz ‚Äî linebackers are rushing the QB instead of covering. Receivers should be open if you throw quick!",wr2:"Blitz ‚Äî linebackers are rushing the QB instead of covering. Receivers should be open if you throw quick!",te:"Blitz ‚Äî defenders committed to the rush and left someone uncovered. Find the open man fast.",rb:"Blitz ‚Äî everyone is rushing the QB! Dump it to the running back before they get there."},
                    goalline:{wr1:"Goal Line ‚Äî defense packed the line to stop the run, so nobody's covering deep. Wide receiver has room outside.",wr2:"Goal Line ‚Äî defense packed the line to stop the run, so nobody's covering deep. Wide receiver has room outside.",te:"Goal Line ‚Äî all defenders stacked at the line of scrimmage. Middle of the field is open downfield.",rb:"Goal Line ‚Äî defense sold out to stop the run. Running back in the flat is wide open."},
                  };
                  const bestWhy=bestIds[0]&&defKey&&whyMap[defKey]?whyMap[defKey][bestIds[0]]:"Look for the most open receiver.";
                  return <div style={{marginBottom:3}}>
                    {isPre(diff)&&bestIds.length>0&&<div style={{fontSize:9,color:"#4ade80",marginBottom:3,padding:"2px 8px",background:"#4ade8012",borderRadius:3,border:"1px solid #4ade8033"}}>üí° {bestWhy}</div>}
                    {isPre(diff)&&primaryCovered&&<div style={{fontSize:9,color:"#fbbf24",marginBottom:3,padding:"2px 8px",background:"#fbbf2412",borderRadius:3,border:"1px solid #fbbf2433"}}>üëÅÔ∏è Your intended receiver ({fmtTarget(primaryId)}) is covered ‚Äî look to your second choice.</div>}
                    <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:3}}>
                      {throws.map(a=>{
                        const isBest=bestIds.includes(a.target);
                        const isPrimary=a.target===primaryId;
                        return <button key={a.target} onClick={()=>doQB(a)} style={{...btn,background:isPrimary?"#0e1828":"#0e1520",border:isPrimary?"1px solid #4a8aaa":"1px solid #2a3550",padding:"4px 6px",color:"#d0dce8",display:"flex",flexDirection:"column",gap:2,textAlign:"left",boxShadow:isBest?"0 0 14px rgba(34,197,94,0.35), 0 0 28px rgba(34,197,94,0.15)":isPrimary?"0 0 8px rgba(74,138,170,0.25)":"none"}}>
                          <div style={{display:"flex",justifyContent:"space-between",width:"100%",alignItems:"center"}}>
                            <span style={{fontWeight:800,fontSize:12}}>{isBest?"‚≠ê ":""}{a.label}{isPrimary?<span style={{fontSize:7,fontWeight:700,color:"#6ab4e0",background:"#142838",padding:"1px 4px",borderRadius:2,marginLeft:4,border:"1px solid #2a4a60"}}>INTENDED</span>:""} <span style={{fontSize:9,color:"#8ab4e0"}}>{a.sub}</span></span>
                            <span style={{fontSize:7,fontWeight:700,color:"#000",background:a.op.col,padding:"1px 3px",borderRadius:2}}>{a.op.lab}</span>
                          </div>
                          <div style={{display:"flex",justifyContent:"space-between",width:"100%",fontSize:10,background:"#05080c",padding:"2px 5px",borderRadius:3,fontFamily:"monospace"}}>
                            <span style={{color:"#4ade80",fontWeight:700}}>HIT:{a.cp}%</span>
                            <span style={{color:"#f87171",fontWeight:700}}>INT:{a.ip}%</span>
                          </div>
                        </button>;
                      })}
                    </div>
                    {scrambleLane&&<button onClick={()=>doQB(scrambleLane)} style={{...btn,background:"#1a2a10",border:"1px solid #4a8a2a",padding:"4px 8px",color:"#86efac",fontSize:11,fontWeight:700,marginTop:3,width:"100%",textAlign:"center"}}>{scrambleLane.label} ‚Äî {scrambleLane.sub}</button>}
                  </div>;
                })()}
                {(()=>{
                  const allActions=getQBActions();
                  const actionBtns=allActions.filter(a=>["move","look","trick","other","escape"].includes(a.cat));
                  const tuckBtns=allActions.filter(a=>a.cat==="tuck");
                  // Determine best 1-2 QB actions for Practice/Preseason highlighting
                  let bestActions=[];
                  let actionTip="";
                  if(isPre(diff)){
                    const hasOpen=["wr1","wr2","te","rb"].some(id=>{const o=opn(id,offP,defPos,defSch);return o.o>=2;});
                    if(pi<30){
                      bestActions=["tuck_run","throw_away"];
                      actionTip="‚ö° Pocket is collapsing! Throw it away or tuck and run ‚Äî don't take the sack.";
                    } else if(pi<50&&phase>=3){
                      bestActions=["tuck_run"];
                      actionTip="‚ö° Pressure is building. Consider tucking and running if nobody's open.";
                    } else if(phase<=1&&!hasOpen){
                      bestActions=["dropback"];
                      actionTip="üìã Receivers are still running their routes. Drop back to give them time to get open.";
                    } else if(hasOpen&&!lookDir){
                      const bestSide=["wr1","te"].some(id=>opn(id,offP,defPos,defSch).o>=2)?"look_left":"look_right";
                      bestActions=[bestSide];
                      actionTip=bestSide==="look_left"?"üëÄ Look Left ‚Äî fools the safety into moving left. Then throw RIGHT where there's less coverage.":"üëÄ Look Right ‚Äî draws the safety to the right. Then throw LEFT where there's less coverage.";
                    } else if(phase>=2&&pi>70&&!hasOpen&&!lookDir){
                      bestActions=["look_left","look_right"];
                      actionTip="üìã Good protection ‚Äî try looking away from your intended receiver to fool the safety, then throw the other way.";
                    } else if(phase>=2&&pi>70&&!hasOpen){
                      bestActions=["dropback"];
                      actionTip="üìã Good protection. Drop back to let routes develop ‚Äî receivers need another beat to get open.";
                    }
                    // Play action tip
                    if(selPlay?.playAction&&phase<=1){
                      actionTip="üé≠ Play Action fakes the handoff ‚Äî it freezes the linebackers and buys your receivers extra time to get open.";
                    }
                  }
                  return <div style={{display:"flex",gap:3,flexWrap:"wrap"}}>
                    {isPre(diff)&&actionTip&&<div style={{fontSize:9,color:"#4ade80",padding:"2px 6px",background:"#4ade8012",borderRadius:3,border:"1px solid #4ade8033",flex:"1 1 100%",marginBottom:1}}>üí° {actionTip}</div>}
                    {actionBtns.map(a=>{
                      const isHighlight=isPre(diff)&&bestActions.includes(a.type);
                      return <button key={a.type} onClick={()=>doQB(a)} style={{...btn,background:"#0e1520",border:"1px solid #2a3550",padding:"3px 6px",color:"#b0c4d8",fontSize:9,fontWeight:600,flex:"1 1 auto",boxShadow:isHighlight?"0 0 14px rgba(34,197,94,0.35), 0 0 28px rgba(34,197,94,0.15)":"none"}}>{a.label}<div style={{fontSize:7,color:"#5a7090"}}>{a.sub}</div></button>;
                    })}
                    {tuckBtns.map(a=>(<button key={a.type} onClick={()=>doQB(a)} style={{...btn,background:"#2a1a00",border:"2px solid #fbbf24",padding:"6px 10px",color:"#fbbf24",fontSize:12,fontWeight:800,flex:"1 1 100%",animation:"pulse 1.2s ease-in-out infinite"}}>{a.label}<div style={{fontSize:8,color:"#d4a034"}}>{a.sub}</div></button>))}
                  </div>;
                })()}
              </div>
            )}

            {mode==="pressure"&&(
              <div style={{background:"#10151f",borderRadius:8,padding:14,border:"2px solid #ef4444",animation:"contactPulse 1s ease-in-out infinite"}}>
                <div style={{fontSize:16,fontWeight:900,color:"#ef4444",marginBottom:4,letterSpacing:1}}>‚ö†Ô∏è PRESSURE!</div>
                <div style={{fontSize:11,color:"#8a9ab0",marginBottom:10}}>Defender closing in ‚Äî make a decision NOW!</div>
                <div style={{fontSize:10,fontWeight:700,marginBottom:8,color:"#5a7090"}}>Phase {phase}</div>
                {(()=>{const po=getPressureOdds();return(<div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:6}}>
                  {pi<30&&phase>=3&&<button onClick={()=>{const loss=rnd(1,3);setPbp(p=>[...p,"Tuck the Ball"]);if(isPre(diff))setCoach("Smart play ‚Äî sometimes the best thing is to hold onto the ball and take a small loss.");endPlay(-loss,`QB tucks the ball ‚Äî loss of ${loss}`,false,false,"Protected the football by going down safely.");}} style={{...btn,gridColumn:"1 / -1",background:"#2a1a00",border:"2px solid #fbbf24",padding:"10px 12px",textAlign:"left",color:"#fbbf24",animation:"pulse 1.2s ease-in-out infinite"}}><div style={{fontSize:14,fontWeight:800}}>üèà TUCK THE BALL</div><div style={{fontSize:10,color:"#d4a034"}}>Small loss, ZERO fumble risk ‚Äî the safe play</div></button>}
                  <button onClick={()=>doPressure("throw_away")} style={{...btn,background:"#0a0e18",border:"1px solid #2a3a50",padding:"8px 10px",textAlign:"left",color:"#8ab4e0"}}><div style={{display:"flex",justifyContent:"space-between",alignItems:"center"}}><span style={{fontSize:12,fontWeight:700}}>üèà Throw It Away</span><span style={{fontSize:9,fontWeight:700,color:"#22c55e",background:"#22c55e22",padding:"1px 5px",borderRadius:3}}>{po.throwAway}%</span></div><div style={{fontSize:9,color:"#5a7090"}}>Incomplete, no INT risk</div></button>
                  <button onClick={()=>doPressure("tuck_run")} style={{...btn,background:"#0a0e18",border:"1px solid #d4a034",padding:"8px 10px",textAlign:"left",color:"#d4a034"}}><div style={{display:"flex",justifyContent:"space-between",alignItems:"center"}}><span style={{fontSize:12,fontWeight:700}}>üèÉ Tuck & Run</span><span style={{fontSize:9,fontWeight:700,color:po.tuckRun>50?"#4ade80":"#fbbf24",background:po.tuckRun>50?"#4ade8022":"#fbbf2422",padding:"1px 5px",borderRadius:3}}>{po.tuckRun}%</span></div><div style={{fontSize:9,color:"#7a6030"}}>QB keeps it, enter run</div></button>
                  <button onClick={()=>doPressure("scramble_left")} style={{...btn,background:"#0a0e18",border:"1px solid #1a2540",padding:"8px 10px",textAlign:"left",color:"#8ab4e0"}}><div style={{display:"flex",justifyContent:"space-between",alignItems:"center"}}><span style={{fontSize:12,fontWeight:700}}>‚Üê Roll Left</span><span style={{fontSize:9,fontWeight:700,color:po.scrL>50?"#4ade80":"#fbbf24",background:po.scrL>50?"#4ade8022":"#fbbf2422",padding:"1px 5px",borderRadius:3}}>{po.scrL}%</span></div><div style={{fontSize:9,color:"#5a7090"}}>3-4yds left, buy time</div></button>
                  <button onClick={()=>doPressure("scramble_right")} style={{...btn,background:"#0a0e18",border:"1px solid #1a2540",padding:"8px 10px",textAlign:"left",color:"#8ab4e0"}}><div style={{display:"flex",justifyContent:"space-between",alignItems:"center"}}><span style={{fontSize:12,fontWeight:700}}>Roll Right ‚Üí</span><span style={{fontSize:9,fontWeight:700,color:po.scrR>50?"#4ade80":"#fbbf24",background:po.scrR>50?"#4ade8022":"#fbbf2422",padding:"1px 5px",borderRadius:3}}>{po.scrR}%</span></div><div style={{fontSize:9,color:"#5a7090"}}>3-4yds right, buy time</div></button>
                </div>);})()}
              </div>
            )}

            {mode==="runner"&&(
              <div>
                <div style={{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:4}}>
                  <div style={{fontSize:11,color:"#f59e0b",fontWeight:700}}>üèÉ {bc.toUpperCase()} ‚Äî MAKE A MOVE</div>
                  <div style={{fontSize:10,color:"#5a7090"}}>{isCatch?`YAC ${runAct}/${MAX_YAC}`:`Move #${runAct+1}`}</div>
                </div>
                {nd&&<div style={{fontSize:10,marginBottom:4,color:nd.d<3?"#ef4444":nd.d<6?"#fbbf24":"#22c55e"}}>
                  {nd.d<3?`‚ö†Ô∏è ${nd.p?.lab} closing! (${nd.d.toFixed(1)}yds)`:nd.d<6?`‚ö° ${nd.p?.lab} nearby (${nd.d.toFixed(1)}yds)`:`‚úì Open field ‚Äî nearest ${nd.p?.lab} ${nd.d.toFixed(1)}yds`}
                </div>}
                <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:5}}>
                  {getRunActions().map((a,i)=>(
                    <button key={i} onClick={()=>doRun(a)} style={{...btn,background:"#0e1520",border:`1px solid ${a.color}44`,padding:"8px 10px",textAlign:"left",color:"#d0dce8"}}>
                      <div style={{display:"flex",justifyContent:"space-between",alignItems:"center"}}>
                        <span style={{fontSize:12,fontWeight:700,color:a.color}}>{a.label}</span>
                        <span style={{fontSize:9,fontWeight:700,color:a.color,background:`${a.color}22`,padding:"1px 5px",borderRadius:3}}>{a.pct}%</span>
                      </div>
                      <div style={{fontSize:9,color:"#6a7a90",marginTop:2}}>{a.sub}</div>
                    </button>
                  ))}
                </div>
              </div>
            )}

            {mode==="contact"&&contactData&&(
              <div style={{background:"#10151f",borderRadius:8,padding:14,border:"2px solid #ef4444",animation:"contactPulse 1s ease-in-out infinite"}}>
                <div style={{fontSize:16,fontWeight:900,color:"#ef4444",marginBottom:4,letterSpacing:1}}>‚ö†Ô∏è CONTACT!</div>
                <div style={{fontSize:11,color:"#8a9ab0",marginBottom:10}}>
                  {contactData.nd.p?.lab||"Defender"} at {contactData.nd.d.toFixed(1)}yds ‚Äî {contactData.d3} defender{contactData.d3>1?"s":""} nearby
                </div>
                {tacklesBroken.current>0&&<div style={{fontSize:9,color:"#fbbf24",marginBottom:6}}>Tackles broken this play: {tacklesBroken.current} ‚Äî risk increases each time</div>}
                <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:6}}>
                  {contactData.options.map(o=>{
                    const fumPct=o.fum/100;
                    const fumCol=fumPct<0.03?"#22c55e":fumPct<0.08?"#fbbf24":"#ef4444";
                    const fumOdds=fumPct>0?Math.round(1/fumPct):0;
                    return(
                    <button key={o.type} onClick={()=>resolveContact(o)} style={{...btn,background:"#0a0e18",border:"1px solid #2a1a1a",padding:"8px 10px",textAlign:"left",color:"#d0dce8"}}>
                      <div style={{fontSize:12,fontWeight:700,marginBottom:4}}>{o.label}</div>
                      {o.type!=="dive"?(<>
                        <div style={{fontSize:10,color:"#22c55e"}}>{o.brk}% break free</div>
                        <div style={{fontSize:10,color:fumCol}}>Fumble: {o.fum}% {fumOdds>0?`(1 in ${fumOdds})`:""}</div>
                        <div style={{fontSize:10,color:"#8a8a8a"}}>Tackled: {o.tck}%</div>
                      </>):(<>
                        <div style={{fontSize:10,color:"#fbbf24"}}>+{o.yds} yards</div>
                        <div style={{fontSize:10,color:"#22c55e",fontWeight:700}}>No fumble risk</div>
                      </>)}
                    </button>);
                  })}
                </div>
              </div>
            )}

            {mode==="result"&&result&&(
              <div style={{display:"flex",alignItems:"center",gap:8,background:"#10151f",borderRadius:6,padding:"6px 12px",border:`1px solid ${result.turnover?"#ef4444":result.incomplete?"#fbbf24":result.yds>=10?"#22c55e":"#1a2540"}`}}>
                <div style={{flex:1,fontSize:12,fontWeight:700,color:result.turnover?"#ef4444":result.incomplete?"#fbbf24":result.yds>=10?"#22c55e":result.yds>=0?"#d0dce8":"#ef4444",lineHeight:1.3}}>
                  {result.turnover?"üí• TURNOVER ‚Äî ":result.incomplete?"‚úã ":result.yds>=15?"üî• ":result.yds>=0?`+${result.yds} ‚Äî `:`${result.yds} ‚Äî `}{result.desc}
                </div>
                <button onClick={advance} style={{...btn,padding:"6px 16px",background:"#162a4a",color:"#4a9eff",border:"1px solid #2a5a9a",fontSize:12,fontWeight:700,whiteSpace:"nowrap",flexShrink:0}}>NEXT ‚Üí</button>
              </div>
            )}

            {/* COACH'S CLIPBOARD ‚Äî Practice/Preseason only, compact one-liner */}
            {(mode==="result"||mode==="touchdown")&&isPre(diff)&&(debrief||coach)&&(
              <div style={{background:"#2a2418",borderRadius:4,padding:"4px 10px",marginTop:4,fontSize:10,color:"#c8b888",lineHeight:1.4}}>
                <span style={{color:"#d4a060",fontWeight:700}}>üìã </span>{debrief||coach}
              </div>
            )}

            {mode==="touchdown"&&(
              <div style={{background:"#10151f",borderRadius:8,padding:16,border:"2px solid #fbbf24",textAlign:"center"}}>
                <div style={{fontSize:22,fontWeight:900,color:"#fbbf24",marginBottom:4}}>üèà TOUCHDOWN! üèà</div>
                <div style={{fontSize:14,color:"#22c55e",fontWeight:700,marginBottom:4}}>+7 POINTS</div>
                <div style={{fontSize:12,color:"#8a9ab0",marginBottom:6}}>{result?.desc}</div>
                {pbp.length>0&&<div style={{fontSize:9,color:"#5a7a9a",marginBottom:8,lineHeight:1.5,padding:"4px 8px",background:"#080c14",borderRadius:4,fontFamily:"monospace",textAlign:"left"}}>{pbp.join(" ‚Üí ")}</div>}
                <button onClick={advance} style={{...btn,width:"100%",padding:12,background:"linear-gradient(135deg,#fbbf24,#f97316)",color:"#000",fontSize:14,fontWeight:800,letterSpacing:1}}>KICKOFF ‚Üí</button>
              </div>
            )}

            {log.length>0&&<div style={{marginTop:8,maxHeight:70,overflowY:"auto",fontSize:10,color:"#4a5a70"}}>{log.map((e,i)=><div key={i} style={{padding:"1px 0",opacity:1-i*0.06}}>{e}</div>)}</div>}
          </div>
          </>}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<TacticalFootball />);
  </script>
</body>
</html>